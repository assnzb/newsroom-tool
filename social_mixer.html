<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ÿ∫ÿ±ŸÅÿ© ÿßŸÑÿ≥Ÿàÿ¥ŸäÿßŸÑ ŸÖŸäÿØŸäÿß | Social Mixer</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;900&display=swap" rel="stylesheet"/>

  <style>
    *{ box-sizing:border-box; }

    body{
      font-family:'Tajawal',sans-serif;
      margin:0; padding:0;
      min-height:100vh;
      display:flex; align-items:center; justify-content:center;
      background:
        linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.7)),
        url("static/images/social_background.jpg") no-repeat center center fixed;
      background-size:cover;
      overflow-x:hidden;
    }

    .home-btn{
      position:absolute; top:30px; left:30px;
      text-decoration:none; color:#fff;
      background:rgba(255,255,255,0.1);
      padding:10px 20px; border-radius:30px;
      display:flex; align-items:center; gap:10px;
      font-weight:900;
      border:1px solid rgba(255,255,255,0.2);
      transition:.3s; z-index:2000;
      backdrop-filter: blur(6px);
    }
    .home-btn:hover{
      background:rgba(255,255,255,0.2);
      transform:scale(1.05);
      border-color:#2ecc71;
      color:#fff;
    }

    .glass-panel{
      background:rgba(20,20,20,0.95);
      border:1px solid #333;
      border-radius:14px;
      width:92%;
      max-width:1280px;
      padding:26px;
      box-shadow:0 20px 50px rgba(0,0,0,0.8);
      position:relative;
    }

    .header-bar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:18px;
      position:relative;
      z-index:60;
      gap:12px;
    }
    .app-logo img{ height:52px; }
    .version-badge{
      background:#333; color:#bbb;
      padding:6px 14px;
      border-radius:15px;
      font-size:.9rem;
      border:1px solid #444;
      font-weight:800;
      white-space:nowrap;
    }

    /* ===== Layout: main + queue right ===== */
    .layout{
      display:grid;
      grid-template-columns: 1fr 330px;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 1050px){
      .layout{ grid-template-columns: 1fr; }
    }

    .main-panel{ min-width:0; }

    .inputs-row{
      display:flex;
      gap:16px;
      margin-bottom:14px;
      direction:ltr !important;
      position:relative;
      z-index:50;
      width:100%;
    }
    @media (max-width: 850px){
      .inputs-row{ flex-direction:column; }
    }
    .input-group{ flex:1; text-align:left; position:relative; }

    .input-label{
      display:block;
      color:#ccc;
      font-size:.95rem;
      font-weight:900;
      text-transform:uppercase;
      margin-bottom:10px;
      letter-spacing:.5px;
    }

    .dark-input{
      width:100%;
      background:#111;
      border:1px solid #444;
      color:#fff;
      padding:14px 16px;
      border-radius:10px;
      font-family:'Tajawal',sans-serif;
      font-size:1rem;
      font-weight:900;
      outline:none;
      transition:.25s;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:space-between;
      direction:ltr;
      gap:10px;
    }
    .dark-input:hover{ border-color:#2ecc71; background:#1a1a1a; }

    .dark-input select{
      background:transparent;
      border:none;
      color:#fff;
      width:100%;
      font-family:'Tajawal';
      font-size:1rem;
      font-weight:900;
      cursor:pointer;
      outline:none;
      appearance:none;
    }
    .dark-input select option{
      background-color:#1a1a1a;
      color:#fff;
      padding:15px;
    }
    #fileNameDisplay{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:100%;
      direction:ltr;
      text-align:left;
    }

    /* ===== Dropzone (before any images) ===== */
    .dropzone{
      width:100%;
      height:520px;
      border:2px dashed #333;
      border-radius:12px;
      background:#050505;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      margin-bottom:16px;
    }
    .dropzone-inner{
      width:min(560px, 92%);
      padding:26px 18px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      text-align:center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .drop-icon{
      width:56px; height:56px;
      border-radius:14px;
      display:flex; align-items:center; justify-content:center;
      margin:0 auto 12px auto;
      background: rgba(59,130,246,0.16);
      border:1px solid rgba(59,130,246,0.35);
    }
    .drop-title{
      font-size:20px;
      font-weight:900;
      margin:0 0 6px 0;
      color:#fff;
    }
    .drop-sub{
      font-size:14px;
      color: rgba(255,255,255,0.75);
      margin:0 0 12px 0;
      line-height:1.7;
    }
    .drop-tip{
      font-size:12px;
      color: rgba(255,255,255,0.55);
      margin:0;
    }
    .dropzone.dragover{
      border-color: rgba(46,204,113,0.95);
      box-shadow: 0 0 0 3px rgba(46,204,113,0.18) inset;
    }

    /* ===== Editor ===== */
    .editor-container{
      width:100%;
      height:520px;
      background:#050505;
      border:2px dashed #333;
      border-radius:12px;
      display:none;
      overflow:hidden;
      position:relative;
      margin-bottom:16px;
      z-index:1;
    }

    .cropper-face{ background-color:transparent !important; opacity:1 !important; }
    .overlay-ghost{
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      z-index:50;
      pointer-events:none !important;
      opacity:.85 !important;
      display:block;
      object-fit:contain;
    }
    .cropper-view-box{ outline:2px solid #2ecc71; }
    .cropper-modal{ opacity:.6; background-color:#000; }
    .cropper-dashed, .cropper-line{ display:none !important; }
    .cropper-point{ width:10px; height:10px; background-color:#2ecc71; opacity:.9; }

    /* ===== Blur Circle (per image, stored in state) ===== */
    #blur-circle{
      position:absolute;
      width:140px; height:140px;
      border-radius:50%;
      border:2px dashed rgba(255,255,255,0.75);
      background:rgba(255,255,255,0.08);
      box-shadow:0 0 18px rgba(0,0,0,0.6);
      z-index:999999;
      display:none;
      cursor:grab;
      user-select:none;
      touch-action:none;
      pointer-events:auto;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      transform:none;
    }
    #blur-circle:active{ cursor:grabbing; border-color:#e67e22; }
    #blur-circle::after{
      content:"BLUR";
      position:absolute;
      top:50%; left:50%;
      transform:translate(-50%,-50%);
      color:rgba(255,255,255,0.75);
      font-size:12px;
      font-weight:900;
      letter-spacing:1px;
      pointer-events:none;
    }

    /* ===== Nav row (prev/next) ===== */
    .nav-row{
      display:flex;
      gap:10px;
      margin-bottom:14px;
      direction:ltr;
      align-items:center;
    }
    .nav-btn{
      flex:1;
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.18);
      color:#fff;
      padding:12px 14px;
      border-radius:12px;
      cursor:pointer;
      transition:.2s;
      font-family:'Tajawal',sans-serif;
      font-weight:900;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      user-select:none;
    }
    .nav-btn:hover{ background: rgba(255,255,255,0.14); transform: translateY(-1px); }
    .nav-btn:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .nav-mid{
      width:190px; min-width:190px;
      text-align:center;
      padding:12px 10px;
      border-radius:12px;
      background: rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.14);
      color: rgba(255,255,255,0.88);
      font-weight:900;
      user-select:none;
    }

    /* ===== Footer ===== */
    .footer-row{ margin-top:10px; position:relative; z-index:50; }

    .blur-controls{
      display:flex;
      gap:10px;
      margin-bottom:12px;
      justify-content:flex-end;
      direction:ltr;
      align-items:center;
      flex-wrap:wrap;
    }
    .blur-btn{
      background:#333; color:#ccc;
      border:1px solid #555;
      padding:8px 15px;
      border-radius:8px;
      cursor:pointer;
      font-weight:900;
      font-size:.9rem;
      transition:.2s;
      display:flex; align-items:center; gap:8px;
      user-select:none;
    }
    .blur-btn:hover{ background:#444; color:#fff; }
    .blur-btn.active{ background:#e67e22; color:#fff; border-color:#e67e22; }

    .intensity-slider-group{
      display:flex; align-items:center; gap:10px; color:#ccc;
      background:#222; padding:6px 14px;
      border-radius:999px;
      border:1px solid #444;
    }
    input[type=range]{ accent-color:#e67e22; cursor:pointer; }
    #intensityValue{
      font-size:.8rem;
      color:#e67e22;
      font-weight:900;
      width:34px;
      text-align:center;
    }

    .filename-container{
      direction:ltr !important;
      text-align:left !important;
      margin-bottom:14px;
      width:100%;
    }
    .filename-container .dark-input{ cursor:text; background:#0a0a0a; }

    .buttons-container{
      display:flex;
      gap:12px;
      margin-top:12px;
      direction:ltr;
    }

    .action-btn{
      background:#e0e0e0;
      color:#000;
      font-weight:900;
      padding:16px;
      border:none;
      border-radius:10px;
      font-size:1.05rem;
      cursor:pointer;
      transition:.25s;
      text-transform:uppercase;
      display:flex; align-items:center; justify-content:center; gap:10px;
      user-select:none;
      width:100%;
    }
    .action-btn:hover{ background:#fff; transform:translateY(-2px); }
    .action-btn:disabled{ background:#333; color:#666; cursor:not-allowed; transform:none; }

    .reset-btn{ background:#c0392b; color:#fff; flex:1; }
    .reset-btn:hover{ background:#e74c3c; }
    .download-btn{ flex:3; }

    /* Panorama add images */
    .panorama-btn-container{ margin-top:10px; display:none; }

    .add-panorama-btn{
      width:100%;
      background:rgba(46,204,113,0.15);
      border:1px solid #2ecc71;
      color:#2ecc71;
      padding:10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:900;
      display:flex; align-items:center; justify-content:center; gap:8px;
      transition:.25s;
      user-select:none;
    }
    .add-panorama-btn:hover{ background:#2ecc71; color:#fff; }

    /* ===== Queue panel ===== */
    .queue-panel{
      background: rgba(0,0,0,0.32);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      position: sticky;
      top: 18px;
      max-height: calc(100vh - 170px);
      overflow:auto;
    }
    .queue-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom: 12px;
      gap:10px;
      direction:ltr;
    }
    .queue-title{
      font-weight: 900;
      color: rgba(255,255,255,0.92);
    }
    .queue-count{
      font-weight: 900;
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
      padding:6px 10px;
      border-radius: 999px;
      white-space:nowrap;
    }
    .queue-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      direction:ltr;
    }
    .queue-item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      cursor:pointer;
      transition:.2s;
      user-select:none;
    }
    .queue-item:hover{
      background: rgba(255,255,255,0.06);
      transform: translateY(-1px);
    }
    .queue-item.active{
      border-color: rgba(46,204,113,0.85);
      box-shadow: 0 0 0 2px rgba(46,204,113,0.18) inset;
      background: rgba(46,204,113,0.10);
    }
    .qi-left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .qi-badge{
      width: 28px;
      height: 28px;
      border-radius: 10px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      background: rgba(255,255,255,0.1);
      border:1px solid rgba(255,255,255,0.15);
      flex: 0 0 auto;
      font-family: 'Tajawal', sans-serif;
    }
    .qi-name{
      font-weight: 900;
      font-size: 13px;
      color: rgba(255,255,255,0.9);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 180px;
      direction:ltr;
    }
    .qi-size{
      font-weight: 900;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      flex: 0 0 auto;
      direction:ltr;
    }

    /* prevent accidental text selection while dragging */
    .no-select{ user-select:none; }
  </style>
</head>

<body>
  <a href="index.html" class="home-btn"><i class="fas fa-home"></i> ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</a>

  <div class="glass-panel">
    <div class="header-bar">
      <div class="app-logo"><img src="static/images/logo.png" alt="Alaraby TV"/></div>
      <div class="version-badge">Unified Version</div>
    </div>

    <div class="layout">
      <!-- MAIN -->
      <div class="main-panel">
        <div class="inputs-row">
          <div class="input-group">
            <span class="input-label">1. SOURCE IMAGE</span>
            <input type="file" id="fileInput" accept="image/*" multiple style="display:none;"/>
            <div class="dark-input" id="uploadTrigger">
              <span id="fileNameDisplay">üìÇ CLICK / DROP IMAGES</span>
              <i class="fa-solid fa-cloud-arrow-up" style="color:#777;"></i>
            </div>
          </div>

          <div class="input-group">
            <span class="input-label">2. SELECT TEMPLATE</span>
            <div class="dark-input">
              <select id="templateSelect">
                <option value="" selected style="color:#aaa;">-- Select Format --</option>
                <option value="headline">TW-slide-headline (1234x1080)</option>
                <option value="avatar">TW-Avatar (400x400)</option>
                <option value="sting">TW-TopicalSting (1920x1080)</option>
                <option value="panorama">TW-Panorama (3562x1075)</option>
                <option value="webscroll">TW-WebScroll (Go to Old Tool)</option>
              </select>
              <i class="fas fa-chevron-down" style="margin-left:10px; color:#888;"></i>
            </div>

            <div class="panorama-btn-container" id="panoramaControls">
              <input type="file" id="panoramaInput" accept="image/*" multiple style="display:none;"/>
              <button class="add-panorama-btn" id="addPanoBtn" type="button">
                <i class="fas fa-plus-circle"></i> ÿ•ÿ∂ÿßŸÅÿ© ÿµŸàÿ± ÿ£ÿÆÿ±Ÿâ ŸÑŸÑÿ®ÿßŸÜŸàÿ±ÿßŸÖÿß
              </button>
            </div>
          </div>
        </div>

        <!-- DROPZONE -->
        <div class="dropzone" id="dropzone">
          <div class="dropzone-inner">
            <div class="drop-icon"><i class="fa-solid fa-cloud-arrow-up"></i></div>
            <p class="drop-title">ÿßÿ±ŸÅÿπ ÿßŸÑÿµŸàÿ± ÿ≠ÿ™Ÿâ ŸÜÿ®ÿØÿ£</p>
            <p class="drop-sub">ÿßÿ≥ÿ≠ÿ® ÿßŸÑÿµŸàÿ± Ÿàÿ£ÿ≥ŸÇÿ∑Ÿáÿß ŸáŸÜÿß ÿ£Ÿà ÿßÿ∂ÿ∫ÿ∑ ŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿπÿØÿ© ÿµŸàÿ± ÿØŸÅÿπÿ© Ÿàÿßÿ≠ÿØÿ©</p>
            <p class="drop-tip">Drag & Drop Ÿäÿ∂ŸäŸÅ ÿµŸàÿ± ÿ¨ÿØŸäÿØÿ© ŸÑŸÑŸÄ Queue ÿ®ÿØŸàŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÇÿØŸäŸÖÿ©</p>
          </div>
        </div>

        <!-- EDITOR -->
        <div class="editor-container" id="editor-area">
          <img id="work-image" src="" style="display:block; max-width:100%;"/>
        </div>

        <!-- NAV -->
        <div class="nav-row" id="navRow" style="display:none;">
          <button class="nav-btn" id="prevBtn"><i class="fa-solid fa-arrow-left"></i> Previous</button>
          <div class="nav-mid" id="navInfo">0 / 0</div>
          <button class="nav-btn" id="nextBtn">Next <i class="fa-solid fa-arrow-right"></i></button>
        </div>

        <!-- FOOTER -->
        <div class="footer-row">
          <div class="blur-controls" id="blurControls" style="display:none;">
            <div class="intensity-slider-group" title="ÿ¥ÿØÿ© ÿßŸÑÿ™ŸÖŸàŸäŸá">
              <i class="fas fa-sliders-h"></i>
              <input type="range" id="blurIntensity" min="10" max="150" value="50"/>
              <span id="intensityValue">50</span>
            </div>
            <button class="blur-btn" id="blurPlus" title="ÿ™ŸÉÿ®Ÿäÿ±" type="button"><i class="fas fa-plus"></i></button>
            <button class="blur-btn" id="blurMinus" title="ÿ™ÿµÿ∫Ÿäÿ±" type="button"><i class="fas fa-minus"></i></button>
            <button class="blur-btn" id="toggleBlurBtn" type="button">
              <i class="fas fa-eye-slash" id="blurToggleIcon"></i> ÿ™ŸÖŸàŸäŸá
            </button>
          </div>

          <div class="filename-container">
            <span class="input-label">3. BASE NAME (WRITE ONCE):</span>
            <input
              type="text"
              id="customFileName"
              class="dark-input"
              placeholder="Type base name (e.g. usa)..."
              style="background:#0a0a0a; cursor:text;"
            />
            <div style="margin-top:8px; font-size:12px; color:rgba(255,255,255,0.55); direction:ltr; text-align:left;" id="nameExample">
              Example: TW_SLIDE_HEADLINE_usa_1.jpg
            </div>
          </div>

          <div class="buttons-container">
            <button id="downloadAllBtn" class="action-btn download-btn" disabled type="button">
              Download All <i class="fas fa-arrow-down"></i>
            </button>
            <button class="action-btn reset-btn" id="resetBtn" type="button">
              Reset <i class="fas fa-redo"></i>
            </button>
          </div>

          <div id="status" style="margin-top:12px; text-align:center;"></div>
        </div>
      </div>

      <!-- QUEUE -->
      <aside class="queue-panel" id="queuePanel">
        <div class="queue-header">
          <div class="queue-title">Queue</div>
          <div class="queue-count" id="queueCount">0 image(s)</div>
        </div>
        <div class="queue-list" id="queueList"></div>
      </aside>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

  <script>
    // ========= GLOBAL =========
    let cropper = null;

    const FEATHER_RATIO = 0.18;

    const templates = {
      headline: { w:1234, h:1080, guide:"static/images/TW-Slide-Headline_guide.png" },
      avatar:   { w:400,  h:400,  guide:"static/images/TW-Avatar_guide.png" },
      sting:    { w:1920, h:1080, guide:null },
      panorama: { w:3562, h:1075, guide:"static/images/TW-Panorama_guide.png" }
    };

    // Queue: each item keeps its own crop + blur state ‚úÖ
    const queue = []; // { file, url, name, sizeText, cropState, blurState }
    let currentIndex = -1;

    // panorama
    let panoramaFiles = [];
    let stitchedObjectUrl = null;

    // blur drag
    let blurDrag = { active:false, startX:0, startY:0, startLeft:0, startTop:0 };

    // ========= DOM =========
    const fileInput = document.getElementById("fileInput");
    const uploadTrigger = document.getElementById("uploadTrigger");
    const fileNameDisplay = document.getElementById("fileNameDisplay");
    const templateSelect = document.getElementById("templateSelect");

    const dropzone = document.getElementById("dropzone");
    const editorArea = document.getElementById("editor-area");
    const workImage = document.getElementById("work-image");

    const navRow = document.getElementById("navRow");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const navInfo = document.getElementById("navInfo");

    const blurControls = document.getElementById("blurControls");
    const blurIntensity = document.getElementById("blurIntensity");
    const intensityValue = document.getElementById("intensityValue");
    const toggleBlurBtn = document.getElementById("toggleBlurBtn");
    const blurToggleIcon = document.getElementById("blurToggleIcon");
    const blurPlus = document.getElementById("blurPlus");
    const blurMinus = document.getElementById("blurMinus");

    const customFileName = document.getElementById("customFileName");
    const nameExample = document.getElementById("nameExample");

    const downloadAllBtn = document.getElementById("downloadAllBtn");
    const resetBtn = document.getElementById("resetBtn");
    const statusEl = document.getElementById("status");

    const panoramaControls = document.getElementById("panoramaControls");
    const panoramaInput = document.getElementById("panoramaInput");
    const addPanoBtn = document.getElementById("addPanoBtn");

    const queueList = document.getElementById("queueList");
    const queueCount = document.getElementById("queueCount");

    // ========= HELPERS =========
    function bytesToMB(bytes){
      const mb = bytes / (1024*1024);
      return (mb < 10 ? mb.toFixed(1) : mb.toFixed(0)) + " MB";
    }

    function setStatus(html){
      statusEl.innerHTML = html || "";
    }

    function getTemplate(){
      const t = templateSelect.value;
      return templates[t] || null;
    }

    function getTemplateLabel(){
      const opt = templateSelect.options[templateSelect.selectedIndex];
      return (opt && opt.textContent) ? opt.textContent.trim() : "";
    }

    function slugTemplateName(label){
      let t = (label || "").replace(/\(.*?\)/g, "").trim();
      t = t.replace(/\s+/g, " ");
      t = t.replace(/[^a-zA-Z0-9]+/g, "_").replace(/^_+|_+$/g, "");
      if(!t) t = "TEMPLATE";
      return t.toUpperCase();
    }

    function safeBaseName(name){
      let safe = (name || "").replace(/[^a-zA-Z0-9\-_ ]/g, "").trim();
      if(!safe) safe = "name";
      return safe;
    }

    function updateExampleName(){
      const prefix = slugTemplateName(getTemplateLabel());
      const base = safeBaseName(customFileName.value.trim() || "usa");
      const count = queue.length;
      if(count <= 1){
        nameExample.textContent = `Example: ${prefix}_${base}.jpg`;
      }else{
        nameExample.textContent = `Example: ${prefix}_${base}_1.jpg ‚Ä¶ ${prefix}_${base}_${count}.jpg`;
      }
    }

    function showEditorOrDropzone(){
      const has = queue.length > 0;
      dropzone.style.display = has ? "none" : "flex";
      editorArea.style.display = has ? "block" : "none";
      navRow.style.display = has ? "flex" : "none";
      blurControls.style.display = has ? "flex" : "none";
    }

    function updateNav(){
      const total = queue.length;
      navInfo.textContent = (total ? (currentIndex + 1) : 0) + " / " + total;
      prevBtn.disabled = (total <= 1 || currentIndex <= 0);
      nextBtn.disabled = (total <= 1 || currentIndex >= total - 1);
      queueCount.textContent = `${total} image(s)`;
      fileNameDisplay.innerHTML = total ? `‚úÖ ${total} image(s) loaded` : "üìÇ CLICK / DROP IMAGES";
    }

    function renderQueue(){
      queueList.innerHTML = "";
      queue.forEach((item, idx) => {
        const row = document.createElement("div");
        row.className = "queue-item" + (idx === currentIndex ? " active" : "");
        row.addEventListener("click", () => goToIndex(idx));

        const left = document.createElement("div");
        left.className = "qi-left";

        const badge = document.createElement("div");
        badge.className = "qi-badge";
        badge.textContent = idx + 1;

        const name = document.createElement("div");
        name.className = "qi-name";
        name.title = item.name;
        name.textContent = item.name;

        left.appendChild(badge);
        left.appendChild(name);

        const size = document.createElement("div");
        size.className = "qi-size";
        size.textContent = item.sizeText;

        row.appendChild(left);
        row.appendChild(size);
        queueList.appendChild(row);
      });
    }

    function checkPanoramaMode(){
      panoramaControls.style.display = (templateSelect.value === "panorama") ? "block" : "none";
    }

    function updateDownloadState(){
      const hasImages = queue.length > 0;
      const hasTemplate = !!getTemplate();
      const hasName = customFileName.value.trim().length > 0;
      downloadAllBtn.disabled = !(hasImages && hasTemplate && hasName);
    }

    // ========= OVERLAY =========
    function removeOverlay(){
      document.querySelectorAll(".overlay-ghost").forEach(el => el.remove());
    }

    function updateOverlay(guidePath){
      removeOverlay();
      if(!guidePath) return;
      const cropBox = document.querySelector(".cropper-face");
      if(!cropBox) return;
      const img = document.createElement("img");
      img.src = guidePath;
      img.className = "overlay-ghost";
      cropBox.appendChild(img);
    }

    // ========= PER-IMAGE SAVE/RESTORE (Crop + Blur) =========
    function saveCurrentState(){
      const item = queue[currentIndex];
      if(!item || !cropper) return;

      // cropper state
      try{
        item.cropState = {
          canvasData: cropper.getCanvasData(),
          cropBoxData: cropper.getCropBoxData(),
          data: cropper.getData(true)
        };
      }catch{}

      // blur state (per image ‚úÖ)
      const circle = document.getElementById("blur-circle");
      const container = document.querySelector(".cropper-container");
      const active = item.blurState ? !!item.blurState.active : false;

      const state = item.blurState || { active:false, intensity:50, size:140, left:0, top:0 };

      // always store current intensity slider value
      state.intensity = parseInt(blurIntensity.value, 10) || 50;

      if(circle && container){
        state.size = parseInt(getComputedStyle(circle).width, 10) || 140;
        state.left = parseFloat(circle.style.left || "0") || 0;
        state.top  = parseFloat(circle.style.top  || "0") || 0;
      }

      // whether blur is currently active (circle visible)
      state.active = activeCircleVisible();

      item.blurState = state;
    }

    function activeCircleVisible(){
      const circle = document.getElementById("blur-circle");
      if(!circle) return false;
      return circle.style.display !== "none";
    }

    function restoreBlurState(){
      const item = queue[currentIndex];
      if(!item) return;

      // set slider first
      const st = item.blurState || { active:false, intensity:50, size:140, left:null, top:null };
      blurIntensity.value = st.intensity ?? 50;
      intensityValue.textContent = blurIntensity.value;

      // ensure circle exists
      const circle = ensureBlurCircle();
      if(!circle) return;

      // size
      const size = st.size ?? 140;
      circle.style.width = size + "px";
      circle.style.height = size + "px";

      // position
      const container = document.querySelector(".cropper-container");
      if(container){
        const rect = container.getBoundingClientRect();
        let left = (st.left != null) ? st.left : Math.max(0, (rect.width - size)/2);
        let top  = (st.top  != null) ? st.top  : Math.max(0, (rect.height - size)/2);

        left = Math.max(0, Math.min(left, rect.width - size));
        top  = Math.max(0, Math.min(top,  rect.height - size));

        circle.style.left = left + "px";
        circle.style.top  = top  + "px";
      }

      // intensity effect
      updateBlurIntensity(blurIntensity.value);

      // show/hide + UI
      if(st.active){
        circle.style.display = "block";
        setBlurBtnUI(true);
      }else{
        circle.style.display = "none";
        setBlurBtnUI(false);
      }
    }

    function initCropperForCurrent(){
      if(cropper){ try{ cropper.destroy(); }catch{} cropper = null; }
      removeOverlay();
      removeBlurCircle(); // recreate per image after ready

      const item = queue[currentIndex];
      if(!item) return;

      const tpl = getTemplate();

      workImage.src = item.url;

      workImage.onload = () => {
        const initialAspectRatio = tpl ? (tpl.w / tpl.h) : NaN;

        cropper = new Cropper(workImage, {
          aspectRatio: initialAspectRatio,
          viewMode: 1,
          // IMPORTANT: avoid "duplicate" behavior while dragging on image
          dragMode: "move",
          cropBoxMovable: true,
          cropBoxResizable: true,
          toggleDragModeOnDblclick: false,
          autoCrop: !!tpl,
          background: false,
          guides: false,
          center: false,
          ready(){
            // apply template if selected
            if(tpl){
              try{ cropper.setAspectRatio(tpl.w / tpl.h); }catch{}
              try{ cropper.crop(); }catch{}
              updateOverlay(tpl.guide);
            }

            // restore crop state
            if(item.cropState){
              try{ cropper.setCanvasData(item.cropState.canvasData); }catch{}
              try{ cropper.setCropBoxData(item.cropState.cropBoxData); }catch{}
              try{ cropper.setData(item.cropState.data); }catch{}
            }

            // restore blur state per image ‚úÖ
            restoreBlurState();

            checkPanoramaMode();
            updateNav();
            renderQueue();
            updateExampleName();
            updateDownloadState();
          },
          cropend(){
            saveCurrentState();
          },
          zoom(){
            setTimeout(saveCurrentState, 50);
          }
        });

        // To allow resizing/moving crop box with dragMode move:
        // when user clicks on crop box -> switch to crop, otherwise move
        const container = document.querySelector(".cropper-container");
        if(container){
          container.addEventListener("pointerdown", (e) => {
            if(!cropper) return;
            // if click inside crop box (face), allow crop interactions
            const face = container.querySelector(".cropper-face");
            if(face && face.contains(e.target)){
              try{ cropper.setDragMode("crop"); }catch{}
            }else{
              try{ cropper.setDragMode("move"); }catch{}
            }
          }, { passive:true });
        }
      };
    }

    function goToIndex(idx){
      if(idx < 0 || idx >= queue.length) return;
      // save old
      saveCurrentState();
      currentIndex = idx;
      initCropperForCurrent();
    }

    // ========= ADD FILES (append) =========
    function addFiles(fileList){
      if(!fileList || !fileList.length) return;

      const files = Array.from(fileList).filter(f => f.type && f.type.startsWith("image/"));
      if(!files.length) return;

      files.forEach(file => {
        const url = URL.createObjectURL(file);
        queue.push({
          file,
          url,
          name: file.name,
          sizeText: bytesToMB(file.size),
          cropState: null,
          blurState: { active:false, intensity:50, size:140, left:null, top:null }
        });
      });

      setStatus(`<span style="color:#4ade80; font-weight:900;">‚úÖ Added ${files.length} image(s) to Queue</span>`);

      showEditorOrDropzone();
      updateNav();
      renderQueue();
      updateExampleName();
      updateDownloadState();

      if(currentIndex === -1 && queue.length > 0){
        currentIndex = 0;
        initCropperForCurrent();
      }
    }

    // ========= DRAG & DROP =========
    function preventDefaults(e){ e.preventDefault(); e.stopPropagation(); }

    ["dragenter","dragover","dragleave","drop"].forEach(ev => {
      dropzone.addEventListener(ev, preventDefaults, false);
      editorArea.addEventListener(ev, preventDefaults, false);
      uploadTrigger.addEventListener(ev, preventDefaults, false);
    });

    function setDragOver(on){
      if(on) dropzone.classList.add("dragover");
      else dropzone.classList.remove("dragover");
    }

    dropzone.addEventListener("dragenter", () => setDragOver(true));
    dropzone.addEventListener("dragover", () => setDragOver(true));
    dropzone.addEventListener("dragleave", () => setDragOver(false));

    dropzone.addEventListener("drop", (e) => {
      setDragOver(false);
      const dt = e.dataTransfer;
      if(dt && dt.files && dt.files.length) addFiles(dt.files);
    });

    editorArea.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      if(dt && dt.files && dt.files.length) addFiles(dt.files);
    });

    dropzone.addEventListener("click", () => fileInput.click());

    // ========= FILE PICKER =========
    uploadTrigger.addEventListener("click", () => fileInput.click());

    fileInput.addEventListener("change", (e) => {
      if(e.target.files && e.target.files.length) addFiles(e.target.files);
      fileInput.value = "";
    });

    // ========= TEMPLATE CHANGE =========
    templateSelect.addEventListener("change", () => {
      if(templateSelect.value === "webscroll"){
        window.location.href = "cleaner.html";
        return;
      }

      checkPanoramaMode();

      if(!queue.length) {
        updateExampleName();
        updateDownloadState();
        return;
      }

      const tpl = getTemplate();
      if(!cropper){
        initCropperForCurrent();
        updateExampleName();
        updateDownloadState();
        return;
      }

      // apply to current image only
      removeOverlay();
      if(tpl){
        try{ cropper.setAspectRatio(tpl.w / tpl.h); }catch{}
        try{ cropper.crop(); }catch{}
        updateOverlay(tpl.guide);
      }else{
        try{ cropper.clear(); }catch{}
      }

      setTimeout(saveCurrentState, 80);
      updateExampleName();
      updateDownloadState();
    });

    // ========= PANORAMA EXTRA IMAGES (for current image only) =========
    addPanoBtn.addEventListener("click", () => panoramaInput.click());

    panoramaInput.addEventListener("change", () => {
      if(panoramaInput.files && panoramaInput.files.length){
        // only if current template is panorama and there is at least one base image
        if(templateSelect.value !== "panorama"){
          panoramaInput.value = "";
          return;
        }
        if(currentIndex < 0) { panoramaInput.value = ""; return; }

        // start pano list with current base image file
        panoramaFiles = [queue[currentIndex].file, ...Array.from(panoramaInput.files)];
        stitchImagesAndReplaceCurrent();
      }
      panoramaInput.value = "";
    });

    function stitchImagesAndReplaceCurrent(){
      if(panoramaFiles.length < 2) return;

      const loadedImages = [];
      let loadedCount = 0;
      const tempUrls = [];

      panoramaFiles.forEach((file) => {
        const im = new Image();
        const url = URL.createObjectURL(file);
        tempUrls.push(url);

        im.onload = () => {
          loadedCount++;
          if(loadedCount === panoramaFiles.length){
            tempUrls.forEach(u => URL.revokeObjectURL(u));
            createStitchedCanvas(loadedImages);
          }
        };

        im.onerror = () => {
          tempUrls.forEach(u => URL.revokeObjectURL(u));
          alert("ÿ™ÿπÿ∞ÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿ•ÿ≠ÿØŸâ ÿµŸàÿ± ÿßŸÑÿ®ÿßŸÜŸàÿ±ÿßŸÖÿß.");
        };

        im.src = url;
        loadedImages.push(im);
      });
    }

    function createStitchedCanvas(images){
      const MAX_CANVAS_WIDTH = 3800;
      const BASE_HEIGHT = 1080;
      const separatorWidth = 20;

      let totalWidthTheoretical = 0;
      images.forEach((img, idx) => {
        const scale = BASE_HEIGHT / img.height;
        totalWidthTheoretical += (img.width * scale);
        if(idx < images.length - 1) totalWidthTheoretical += separatorWidth;
      });

      let reductionRatio = 1;
      if(totalWidthTheoretical > MAX_CANVAS_WIDTH){
        reductionRatio = MAX_CANVAS_WIDTH / totalWidthTheoretical;
      }

      const finalWidth  = Math.max(1, Math.round(totalWidthTheoretical * reductionRatio));
      const finalHeight = Math.max(1, Math.round(BASE_HEIGHT * reductionRatio));

      const canvas = document.createElement("canvas");
      canvas.width = finalWidth;
      canvas.height = finalHeight;
      const ctx = canvas.getContext("2d", { alpha:false });

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let currentX = 0;
      images.forEach((img, idx) => {
        const baseScale = BASE_HEIGHT / img.height;
        const drawWidth = Math.round((img.width * baseScale) * reductionRatio);
        const drawHeight = finalHeight;

        ctx.drawImage(img, currentX, 0, drawWidth, drawHeight);
        currentX += drawWidth;
        if(idx < images.length - 1) currentX += Math.round(separatorWidth * reductionRatio);
      });

      if(stitchedObjectUrl) URL.revokeObjectURL(stitchedObjectUrl);

      canvas.toBlob((blob) => {
        if(!blob){
          alert("ŸÅÿ¥ŸÑ ÿØŸÖÿ¨ ÿßŸÑÿµŸàÿ±.");
          return;
        }

        stitchedObjectUrl = URL.createObjectURL(blob);

        // Replace current item image with stitched result
        const item = queue[currentIndex];
        if(!item) return;

        // revoke old
        try{ URL.revokeObjectURL(item.url); }catch{}
        item.url = stitchedObjectUrl;
        item.name = "panorama_stitched.jpg";
        item.sizeText = "stitched";

        // reset per-image crop state but keep per-image blur state
        item.cropState = null;

        initCropperForCurrent();
        renderQueue();
        updateNav();
        updateDownloadState();
      }, "image/jpeg", 0.88);
    }

    // ========= BLUR UI + PER IMAGE =========
    function setBlurBtnUI(active){
      if(active){
        toggleBlurBtn.classList.add("active");
        blurToggleIcon.className = "fas fa-eye";
      }else{
        toggleBlurBtn.classList.remove("active");
        blurToggleIcon.className = "fas fa-eye-slash";
      }
    }

    function getCropperContainer(){
      return document.querySelector(".cropper-container");
    }

    function ensureBlurCircle(){
      const container = getCropperContainer();
      if(!container) return null;

      let circle = document.getElementById("blur-circle");
      if(circle) return circle;

      circle = document.createElement("div");
      circle.id = "blur-circle";
      container.appendChild(circle);

      // center by default
      const rect = container.getBoundingClientRect();
      const size = 140;
      circle.style.left = Math.max(0, (rect.width - size) / 2) + "px";
      circle.style.top  = Math.max(0, (rect.height - size) / 2) + "px";

      circle.addEventListener("pointerdown", onBlurPointerDown, { passive:false });

      return circle;
    }

    function removeBlurCircle(){
      const c = document.getElementById("blur-circle");
      if(c) c.remove();
    }

    function onBlurPointerDown(e){
      const circle = e.currentTarget;
      const container = getCropperContainer();
      if(!container) return;

      // allow dragging only when circle is visible
      if(circle.style.display === "none") return;

      e.preventDefault();
      e.stopPropagation();

      circle.setPointerCapture(e.pointerId);

      const circleRect = circle.getBoundingClientRect();
      const contRect = container.getBoundingClientRect();

      blurDrag.active = true;
      blurDrag.startX = e.clientX;
      blurDrag.startY = e.clientY;
      blurDrag.startLeft = circleRect.left - contRect.left;
      blurDrag.startTop  = circleRect.top  - contRect.top;

      window.addEventListener("pointermove", onBlurPointerMove, { passive:false });
      window.addEventListener("pointerup", onBlurPointerUp, { passive:false });
    }

    function onBlurPointerMove(e){
      if(!blurDrag.active) return;
      e.preventDefault();

      const container = getCropperContainer();
      const circle = document.getElementById("blur-circle");
      if(!container || !circle) return;

      const contRect = container.getBoundingClientRect();
      const size = parseInt(getComputedStyle(circle).width, 10);

      const dx = e.clientX - blurDrag.startX;
      const dy = e.clientY - blurDrag.startY;

      let newLeft = blurDrag.startLeft + dx;
      let newTop  = blurDrag.startTop  + dy;

      newLeft = Math.max(0, Math.min(newLeft, contRect.width - size));
      newTop  = Math.max(0, Math.min(newTop,  contRect.height - size));

      circle.style.left = newLeft + "px";
      circle.style.top  = newTop  + "px";

      // save per-image while dragging
      saveCurrentState();
    }

    function onBlurPointerUp(){
      blurDrag.active = false;
      window.removeEventListener("pointermove", onBlurPointerMove);
      window.removeEventListener("pointerup", onBlurPointerUp);
      saveCurrentState();
    }

    function updateBlurIntensity(val){
      intensityValue.textContent = val;
      const circle = document.getElementById("blur-circle");
      if(!circle) return;
      const cssBlur = (parseInt(val, 10) || 50) / 10;
      circle.style.backdropFilter = `blur(${cssBlur}px)`;
      circle.style.webkitBackdropFilter = `blur(${cssBlur}px)`;
      saveCurrentState();
    }

    function resizeBlur(delta){
      const circle = document.getElementById("blur-circle");
      if(!circle || circle.style.display === "none") return;

      const container = getCropperContainer();
      if(!container) return;

      const contRect = container.getBoundingClientRect();
      let size = parseInt(getComputedStyle(circle).width, 10);
      size += delta;

      if(size < 30) size = 30;
      if(size > Math.min(contRect.width, contRect.height)) size = Math.min(contRect.width, contRect.height);

      const left = parseFloat(circle.style.left || "0");
      const top  = parseFloat(circle.style.top  || "0");
      const oldSize = parseInt(getComputedStyle(circle).width, 10);

      const cx = left + oldSize/2;
      const cy = top  + oldSize/2;

      let newLeft = cx - size/2;
      let newTop  = cy - size/2;

      newLeft = Math.max(0, Math.min(newLeft, contRect.width - size));
      newTop  = Math.max(0, Math.min(newTop,  contRect.height - size));

      circle.style.width = size + "px";
      circle.style.height = size + "px";
      circle.style.left = newLeft + "px";
      circle.style.top  = newTop  + "px";

      saveCurrentState();
    }

    function toggleBlur(){
      if(!cropper) return;
      const circle = ensureBlurCircle();
      if(!circle) return;

      const item = queue[currentIndex];
      if(!item) return;

      const isVisible = circle.style.display !== "none";

      if(isVisible){
        circle.style.display = "none";
        setBlurBtnUI(false);
        item.blurState.active = false;
      }else{
        circle.style.display = "block";
        setBlurBtnUI(true);
        item.blurState.active = true;
        updateBlurIntensity(blurIntensity.value);
      }
      saveCurrentState();
    }

    // ========= APPLY BLUR TO EXPORT (per image) =========
    function applyBlurFeatherToFinalCanvas(finalCanvas, outW, outH){
      const item = queue[currentIndex];
      if(!item || !item.blurState || !item.blurState.active) return finalCanvas;

      const circle = document.getElementById("blur-circle");
      const container = getCropperContainer();
      if(!circle || !container || !cropper) return finalCanvas;

      const cropBox = cropper.getCropBoxData();
      const contRect = container.getBoundingClientRect();
      const circleRect = circle.getBoundingClientRect();

      const cx = (circleRect.left - contRect.left) + circleRect.width / 2;
      const cy = (circleRect.top  - contRect.top ) + circleRect.height / 2;
      const r  = circleRect.width / 2;

      const u = (cx - cropBox.left) / cropBox.width;
      const v = (cy - cropBox.top ) / cropBox.height;
      const rr = r / cropBox.width;

      if(u < -0.2 || v < -0.2 || u > 1.2 || v > 1.2) return finalCanvas;

      const outCx = u * outW;
      const outCy = v * outH;
      const outR  = rr * outW;

      const strength = parseInt(item.blurState.intensity || blurIntensity.value, 10);
      const blurPx = Math.max(3, Math.round(strength / 6));

      const ctx = finalCanvas.getContext("2d");

      // base
      const base = document.createElement("canvas");
      base.width = outW; base.height = outH;
      base.getContext("2d").drawImage(finalCanvas, 0, 0);

      // blurred
      const blurred = document.createElement("canvas");
      blurred.width = outW; blurred.height = outH;
      const bctx = blurred.getContext("2d");
      bctx.filter = `blur(${blurPx}px)`;
      bctx.drawImage(base, 0, 0);
      bctx.filter = "none";

      // mask
      const mask = document.createElement("canvas");
      mask.width = outW; mask.height = outH;
      const mctx = mask.getContext("2d");
      const inner = Math.max(0, outR * (1 - FEATHER_RATIO));
      const outer = outR;

      const grad = mctx.createRadialGradient(outCx, outCy, inner, outCx, outCy, outer);
      grad.addColorStop(0, "rgba(255,255,255,1)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      mctx.fillStyle = grad;
      mctx.fillRect(0, 0, outW, outH);

      // blurMasked
      const blurMasked = document.createElement("canvas");
      blurMasked.width = outW; blurMasked.height = outH;
      const bm = blurMasked.getContext("2d");
      bm.drawImage(blurred, 0, 0);
      bm.globalCompositeOperation = "destination-in";
      bm.drawImage(mask, 0, 0);
      bm.globalCompositeOperation = "source-over";

      ctx.clearRect(0, 0, outW, outH);
      ctx.drawImage(base, 0, 0);
      ctx.drawImage(blurMasked, 0, 0);

      return finalCanvas;
    }

    // ========= DOWNLOAD ALL =========
    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function setProcessing(on){
      if(on){
        downloadAllBtn.disabled = true;
        downloadAllBtn.innerHTML = 'Processing... <i class="fas fa-spinner fa-spin"></i>';
      }else{
        downloadAllBtn.innerHTML = 'Download All <i class="fas fa-arrow-down"></i>';
        updateDownloadState();
      }
    }

    downloadAllBtn.addEventListener("click", async () => {
      const tpl = getTemplate();
      if(!tpl){
        alert("ÿßÿÆÿ™Ÿéÿ± ÿßŸÑŸÇÿßŸÑÿ® ÿ£ŸàŸÑÿßŸã.");
        return;
      }
      const base = customFileName.value.trim();
      if(!base){
        alert("ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ ÿßŸÑŸÄ Base ÿ£ŸàŸÑÿßŸã.");
        updateDownloadState();
        return;
      }
      if(!queue.length) return;

      saveCurrentState();

      const prefix = slugTemplateName(getTemplateLabel());
      const safeBase = safeBaseName(base);
      const total = queue.length;
      const originalIdx = currentIndex;

      setProcessing(true);
      setStatus(`<span style="color:#4ade80; font-weight:900;">‚è≥ Preparing ${total} image(s)...</span>`);

      try{
        for(let i=0;i<total;i++){
          await new Promise(res => { goToIndex(i); setTimeout(res, 200); });

          let finalCanvas = cropper.getCroppedCanvas({
            width: tpl.w,
            height: tpl.h,
            fillColor:"#fff",
            imageSmoothingEnabled:true,
            imageSmoothingQuality:"medium"
          });

          if(!finalCanvas) throw new Error("Canvas generation failed");

          // per-image blur ‚úÖ
          finalCanvas = applyBlurFeatherToFinalCanvas(finalCanvas, tpl.w, tpl.h);

          const suffix = (total > 1) ? `_${i+1}` : "";
          const fileName = `${prefix}_${safeBase}${suffix}.jpg`;

          await new Promise(resolve => {
            finalCanvas.toBlob((blob) => {
              if(blob) downloadBlob(blob, fileName);
              resolve();
            }, "image/jpeg", 0.90);
          });

          setStatus(`<span style="color:#4ade80; font-weight:900;">‚úÖ Downloaded ${i+1}/${total}</span>`);
          await new Promise(r => setTimeout(r, 120));
        }

        if(originalIdx >= 0 && originalIdx < total){
          goToIndex(originalIdx);
        }

        setStatus(`<span style="color:#4ade80; font-weight:900;">‚úÖ Done! Downloaded ${total} image(s)</span>`);
      }catch(e){
        console.error(e);
        setStatus(`<span style="color:#f87171; font-weight:900;">‚ùå Error while exporting. Try again.</span>`);
      }finally{
        setProcessing(false);
      }
    });

    // ========= RESET =========
    resetBtn.addEventListener("click", () => {
      // revoke urls
      queue.forEach(it => { try{ URL.revokeObjectURL(it.url); }catch{} });
      queue.length = 0;
      currentIndex = -1;

      panoramaFiles = [];
      if(stitchedObjectUrl){ try{ URL.revokeObjectURL(stitchedObjectUrl); }catch{} stitchedObjectUrl = null; }

      if(cropper){ try{ cropper.destroy(); }catch{} cropper = null; }
      removeOverlay();
      removeBlurCircle();

      templateSelect.selectedIndex = 0;
      customFileName.value = "";
      blurIntensity.value = 50;
      intensityValue.textContent = "50";

      setStatus("");
      renderQueue();
      updateNav();
      showEditorOrDropzone();
      updateExampleName();
      updateDownloadState();
      checkPanoramaMode();
    });

    // ========= NAV =========
    prevBtn.addEventListener("click", () => {
      if(currentIndex > 0) goToIndex(currentIndex - 1);
    });
    nextBtn.addEventListener("click", () => {
      if(currentIndex < queue.length - 1) goToIndex(currentIndex + 1);
    });

    // ========= BLUR EVENTS =========
    blurIntensity.addEventListener("input", (e) => updateBlurIntensity(e.target.value));
    toggleBlurBtn.addEventListener("click", toggleBlur);
    blurPlus.addEventListener("click", () => resizeBlur(10));
    blurMinus.addEventListener("click", () => resizeBlur(-10));

    // ========= INPUT EVENTS =========
    customFileName.addEventListener("input", () => {
      updateExampleName();
      updateDownloadState();
    });

    // ========= INIT =========
    window.addEventListener("DOMContentLoaded", () => {
      showEditorOrDropzone();
      renderQueue();
      updateNav();
      updateExampleName();
      updateDownloadState();
      checkPanoramaMode();
    });
  </script>
</body>
</html>
