<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ÿ∫ÿ±ŸÅÿ© ÿßŸÑÿ≥Ÿàÿ¥ŸäÿßŸÑ ŸÖŸäÿØŸäÿß | Social Hub</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;900&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; }

    body {
      font-family: 'Tajawal', sans-serif;
      background: #000;
      margin: 0; padding: 0;
      min-height: 100vh;
      display: flex; align-items: center; justify-content: center;
      background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.7)),
                  url('static/images/social_background.jpg') no-repeat center center fixed;
      background-size: cover;
    }

    .home-btn {
      position: absolute; top: 30px; left: 30px;
      text-decoration: none; color: #fff;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 20px; border-radius: 30px;
      display: flex; align-items: center; gap: 10px;
      font-weight: bold; font-family: 'Tajawal', sans-serif;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: 0.3s; z-index: 2000; backdrop-filter: blur(5px);
    }
    .home-btn:hover {
      background: rgba(255, 255, 255, 0.2); transform: scale(1.05);
      text-decoration: none; color: #fff; border-color: #2ecc71;
    }

    .glass-panel {
      background: rgba(20, 20, 20, 0.95);
      border: 1px solid #333; border-radius: 14px;
      width: 92%; max-width: 1350px; padding: 30px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.8);
      position: relative;
    }

    .header-bar {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 18px; position: relative; z-index: 60;
    }
    .app-logo img { height: 55px; }
    .version-badge {
      background: #333; color: #bbb;
      padding: 6px 15px; border-radius: 15px;
      font-size: 0.9rem; border: 1px solid #444;
    }

    .layout-grid { display: grid; gap: 16px; align-items: start; }
    .layout-grid.no-queue { grid-template-columns: 1fr; }
    .layout-grid.has-queue { grid-template-columns: 1fr 360px; }

    @media (max-width: 980px) {
      .layout-grid.no-queue,
      .layout-grid.has-queue { grid-template-columns: 1fr; }
    }

    .inputs-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 14px;
      direction: ltr !important;
      position: relative; z-index: 50; width: 100%;
    }
    @media (max-width: 980px) {
      .inputs-row { grid-template-columns: 1fr; }
    }

    .input-group { text-align: left; position: relative; }
    .input-label {
      display: block; color: #ccc; font-size: 0.95rem;
      font-weight: 800; text-transform: uppercase; margin-bottom: 10px;
      letter-spacing: 0.5px;
    }

    .dark-input {
      width: 100%;
      background: #111;
      border: 1px solid #444;
      color: #fff;
      padding: 14px 18px;
      border-radius: 10px;
      font-family: 'Tajawal', sans-serif;
      font-size: 1rem; font-weight: 800;
      outline: none;
      transition: 0.25s;
      cursor: pointer;
      display: flex; align-items: center; justify-content: space-between;
      direction: ltr;
    }
    .dark-input:hover { border-color: #2ecc71; background: #1a1a1a; }

    .dark-input select {
      background: transparent; border: none; color: white; width: 100%;
      font-family: 'Tajawal'; font-size: 1rem; font-weight: 800;
      cursor: pointer; outline: none; appearance: none;
    }
    .dark-input select option { background-color: #1a1a1a; color: white; padding: 15px; }
    #fileNameDisplay { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; direction: ltr; text-align: left; }

    .nav-row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
      direction: ltr;
      position: relative;
      z-index: 60;
    }

    .btn-secondary {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #fff;
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 900;
      cursor: pointer;
      transition: 0.2s;
      width: 100%;
    }
    .btn-secondary:hover { background: rgba(255,255,255,0.14); transform: translateY(-1px); }
    .btn-secondary:disabled { opacity: 0.45; cursor: not-allowed; transform: none; }

    .editor-container {
      width: 100%;
      height: 560px;
      background: #050505;
      border: 2px dashed #333;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      z-index: 1;
    }

    /* ‚úÖ ŸÖŸÜÿπ ÿßŸÑÿ≥ÿ≠ÿ®/ÿßŸÑŸÄ ghost */
    #work-image {
      display: block;
      max-width: 100%;
      -webkit-user-drag: none;
      user-drag: none;
      user-select: none;
      pointer-events: auto;
    }

    .dropzone {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      text-align: center;
      cursor: pointer;
      user-select: none;
      z-index: 20;
    }
    .drop-card {
      width: min(720px, 92%);
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 18px;
      padding: 22px 20px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: 0.18s;
    }
    .drop-icon {
      width: 54px; height: 54px;
      border-radius: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(46, 204, 113, 0.14);
      border: 1px solid rgba(46, 204, 113, 0.30);
      margin-bottom: 12px;
      font-size: 22px;
      color: #a7f3d0;
    }
    .drop-title {
      font-weight: 900;
      font-size: 1.05rem;
      margin-bottom: 8px;
      color: #e5e7eb;
    }
    .drop-sub {
      font-size: 0.92rem;
      line-height: 1.45;
      color: #a3a3a3;
      margin-bottom: 10px;
    }
    .drop-hint {
      font-size: 0.85rem;
      color: #9ca3af;
      direction: ltr;
    }
    .dropzone.dragover .drop-card {
      transform: scale(1.02);
      border-color: rgba(46, 204, 113, 0.75);
      background: rgba(46, 204, 113, 0.10);
      box-shadow: 0 18px 45px rgba(0,0,0,0.45);
    }

    .cropper-face { background-color: transparent !important; opacity: 1 !important; }
    .cropper-view-box { outline: 2px solid #2ecc71; }
    .cropper-modal { opacity: 0.6; background-color: #000; }
    .cropper-dashed, .cropper-line { display: none !important; }
    .cropper-point { width: 10px; height: 10px; background-color: #2ecc71; opacity: 0.9; }

    .overlay-ghost {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none !important;
      z-index: 9999;
      opacity: 0.9 !important;
      object-fit: fill;
      -webkit-user-drag: none;
      user-select: none;
    }

    #blur-circle {
      position: absolute;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      border: 2px dashed rgba(255,255,255,0.75);
      background: rgba(255,255,255,0.08);
      box-shadow: 0 0 18px rgba(0,0,0,0.6);
      z-index: 999999;
      display: none;
      cursor: grab;
      user-select: none;
      touch-action: none;
      pointer-events: auto;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    #blur-circle:active { cursor: grabbing; border-color: #e67e22; }
    #blur-circle::after {
      content: "BLUR";
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255,255,255,0.75);
      font-size: 12px;
      font-weight: 900;
      letter-spacing: 1px;
      pointer-events: none;
    }

    .footer-row { margin-top: 14px; position: relative; z-index: 60; }

    .blur-controls {
      display: flex; gap: 10px; margin-bottom: 12px; justify-content: flex-end;
      direction: ltr; align-items: center;
    }
    .blur-btn {
      background: #333; color: #ccc; border: 1px solid #555;
      padding: 8px 15px; border-radius: 8px; cursor: pointer; font-weight: 900;
      font-size: 0.9rem; transition: 0.2s; display: flex; align-items: center; gap: 8px;
    }
    .blur-btn:hover { background: #444; color: white; }
    .blur-btn.active { background: #e67e22; color: white; border-color: #e67e22; }

    .intensity-slider-group {
      display: flex; align-items: center; gap: 10px; color: #ccc;
      background: #222; padding: 6px 14px; border-radius: 999px;
      border: 1px solid #444; margin-right: 10px;
    }
    input[type=range] { accent-color: #e67e22; cursor: pointer; }
    #intensityValue { font-size: 0.8rem; color: #e67e22; font-weight: 900; width: 30px; text-align: center; }

    .filename-container { direction: ltr !important; text-align: left !important; margin-bottom: 10px; width: 100%; }
    .filename-container .input-label { text-align: left; }

    .base-name-input {
      width: 100%;
      background: #0a0a0a;
      cursor: text;
      border: 1px solid #444;
      color: #fff;
      padding: 14px 18px;
      border-radius: 10px;
      font-family: 'Tajawal', sans-serif;
      font-size: 1rem; font-weight: 800;
      outline: none;
      transition: 0.25s;
      direction: ltr;
    }
    .base-name-input:focus { border-color: #2ecc71; background: #0f0f0f; }

    .hint {
      margin-top: 6px;
      font-size: 0.9rem;
      color: #a3a3a3;
      direction: ltr;
      text-align: left;
    }

    .buttons-container { display: flex; gap: 12px; margin-top: 14px; direction: ltr; }
    .action-btn {
      background: #e0e0e0; color: #000; font-weight: 900;
      padding: 14px; border: none; border-radius: 10px; font-size: 1.05rem;
      cursor: pointer; transition: 0.25s; text-transform: uppercase;
      display: flex; align-items: center; justify-content: center; gap: 10px;
      flex: 1;
    }
    .action-btn:hover { background: #fff; transform: translateY(-2px); }
    .action-btn:disabled { background: #333; color: #666; cursor: not-allowed; transform: none; }
    .reset-btn { background: #c0392b; color: white; }
    .reset-btn:hover { background: #e74c3c; }

    .panorama-btn-container { margin-top: 10px; display: none; direction: ltr; }
    .add-panorama-btn {
      width: 100%;
      background: rgba(46, 204, 113, 0.15);
      border: 1px solid #2ecc71;
      color: #2ecc71;
      padding: 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 900;
      display: flex; align-items: center; justify-content: center; gap: 8px;
      transition: 0.25s;
    }
    .add-panorama-btn:hover { background: #2ecc71; color: white; }

    .queue-wrap {
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      position: sticky;
      top: 16px;
      height: calc(560px + 260px);
      display: flex;
      flex-direction: column;
    }
    @media (max-width: 980px) {
      .queue-wrap { position: relative; top: auto; height: auto; }
    }

    .queue-title {
      display: flex; align-items: center; justify-content: space-between;
      font-weight: 900;
      margin-bottom: 12px;
      color: #e5e7eb;
    }
    .queue-title small { font-weight: 800; color: #a3a3a3; direction: ltr; }
    .queue-list { overflow: auto; padding-right: 4px; flex: 1; }

    .queue-item {
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      margin-bottom: 10px;
      cursor: pointer;
      transition: 0.15s;
      direction: ltr;
    }
    .queue-item:hover { background: rgba(255,255,255,0.07); }
    .queue-item.active {
      border-color: rgba(46, 204, 113, 0.85);
      background: rgba(46, 204, 113, 0.14);
    }
    .queue-left { display: flex; align-items: center; gap: 10px; min-width: 0; }
    .queue-badge {
      min-width: 28px; height: 28px;
      display: inline-flex; align-items: center; justify-content: center;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      font-weight: 900;
      color: #e5e7eb;
      flex: 0 0 auto;
    }
    .queue-name {
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      max-width: 220px;
      direction: ltr;
      font-weight: 800;
      color: #e5e7eb;
    }
    .queue-size { font-size: 0.85rem; color: #a3a3a3; flex: 0 0 auto; direction: ltr; }
  </style>
</head>

<body>
  <a href="index.html" class="home-btn"><i class="fas fa-home"></i> ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</a>

  <div class="glass-panel">
    <div class="header-bar">
      <div class="app-logo"><img src="static/images/logo.png" alt="Alaraby TV"></div>
      <div class="version-badge">Unified Version</div>
    </div>

    <div class="layout-grid no-queue" id="layoutGrid">
      <div>
        <div class="inputs-row">
          <div class="input-group">
            <span class="input-label">1. SOURCE IMAGE</span>
            <input type="file" id="fileInput" accept="image/*" multiple style="display:none;">
            <div class="dark-input" id="filePicker">
              <span id="fileNameDisplay">üìÇ CLICK TO UPLOAD IMAGE</span>
            </div>
          </div>

          <div class="input-group">
            <span class="input-label">2. SELECT TEMPLATE</span>
            <div class="dark-input">
              <select id="templateSelect">
                <option value="" selected style="color:#aaa;">-- Select Format --</option>
                <option value="headline">TW-slide-headline (1234x1080)</option>
                <option value="avatar">TW-Avatar (400x400)</option>
                <option value="sting">TW-TopicalSting (1920x1080)</option>
                <option value="panorama">TW-Panorama (3562x1075)</option>
                <option value="webscroll">TW-WebScroll (Go to Old Tool)</option>
              </select>
              <i class="fas fa-chevron-down" style="margin-left:10px;color:#888;"></i>
            </div>

            <div class="panorama-btn-container" id="panoramaControls">
              <input type="file" id="panoramaInput" accept="image/*" multiple style="display:none;">
              <button class="add-panorama-btn" id="panoramaAddBtn" type="button">
                <i class="fas fa-plus-circle"></i> ÿ•ÿ∂ÿßŸÅÿ© ÿµŸàÿ± ÿ£ÿÆÿ±Ÿâ ŸÑŸÑÿ®ÿßŸÜŸàÿ±ÿßŸÖÿß (ŸÑŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©)
              </button>
            </div>
          </div>
        </div>

        <div class="nav-row">
          <button id="prevBtn" class="btn-secondary" disabled>‚¨ÖÔ∏è Previous</button>
          <button id="infoBtn" class="btn-secondary" disabled style="cursor:default;">0 / 0</button>
          <button id="nextBtn" class="btn-secondary" disabled>Next ‚û°Ô∏è</button>
        </div>

        <div class="editor-container" id="editor-area">
          <img id="work-image" src="" alt="" draggable="false">
          <div class="dropzone" id="dropzone">
            <div class="drop-card">
              <div class="drop-icon"><i class="fa-solid fa-cloud-arrow-up"></i></div>
              <div class="drop-title">ÿßÿ±ŸÅÿπ ÿßŸÑÿµŸàÿ± ÿ≠ÿ™Ÿâ ŸÜÿ®ÿØÿ£</div>
              <div class="drop-sub">
                ÿßÿ≥ÿ≠ÿ® ÿßŸÑÿµŸàÿ± Ÿàÿ£ŸÅŸÑÿ™Ÿáÿß ŸáŸÜÿßÿå ÿ£Ÿà ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÅÿ™ÿ≠ ŸÜÿßŸÅÿ∞ÿ© ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖŸÑŸÅÿßÿ™.<br>
                ŸàŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ•ÿ∂ÿßŸÅÿ© ŸÑÿßÿ≠ŸÇÿßŸã ÿ®ÿØŸàŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑÿµŸàÿ± ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©.
              </div>
              <div class="drop-hint">Tip: Multiple Images (PNG/JPG/WebP)</div>
            </div>
          </div>
        </div>

        <div class="footer-row">
          <div class="blur-controls" id="blurControls" style="display:none;">
            <div class="intensity-slider-group" title="ÿ¥ÿØÿ© ÿßŸÑÿ™ŸÖŸàŸäŸá">
              <i class="fas fa-sliders-h"></i>
              <input type="range" id="blurIntensity" min="10" max="150" value="50">
              <span id="intensityValue">50</span>
            </div>
            <button class="blur-btn" id="blurPlusBtn" title="ÿ™ŸÉÿ®Ÿäÿ±" type="button"><i class="fas fa-plus"></i></button>
            <button class="blur-btn" id="blurMinusBtn" title="ÿ™ÿµÿ∫Ÿäÿ±" type="button"><i class="fas fa-minus"></i></button>
            <button class="blur-btn" id="toggleBlurBtn" type="button">
              <i class="fas fa-eye-slash" id="blurToggleIcon"></i> ÿ™ŸÖŸàŸäŸá
            </button>
          </div>

          <div class="filename-container">
            <span class="input-label">3. BASE NAME (WRITE ONCE):</span>
            <input type="text" id="customFileName" class="base-name-input" placeholder="Type base name (e.g. usa)...">
            <div class="hint" id="finalPreview">Example: TEMPLATE_usa_1.jpg</div>
          </div>

          <div class="buttons-container">
            <button id="downloadBtn" class="action-btn" disabled type="button">
              Download All <i class="fas fa-arrow-down"></i>
            </button>
            <button class="action-btn reset-btn" id="resetBtn" type="button">
              Reset <i class="fas fa-redo"></i>
            </button>
          </div>
        </div>

        <div id="status" style="margin-top:12px;text-align:center;color:#bbb;"></div>
      </div>

      <div class="queue-wrap" id="queueWrap" style="display:none;">
        <div class="queue-title">
          <div>Queue</div>
          <small id="queueMeta">0 image(s)</small>
        </div>
        <div class="queue-list" id="queueList"></div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <script>
    let cropper = null;

    let imageQueue = [];
    let currentIndex = -1;
    let currentObjectURL = null;

    const cropStateByIndex = new Map();

    // ‚úÖ Blur state PER IMAGE
    // { active:boolean, left:number, top:number, size:number, intensity:number }
    const blurStateByIndex = new Map();

    const panoramaFilesByIndex = new Map();

    // ‚úÖ Panorama preview cache (per image index)
    const panoramaRenderedURLByIndex = new Map();

    let cropperReadyResolver = null;

    let blurDrag = { active:false, startX:0, startY:0, startLeft:0, startTop:0 };

    const FEATHER_RATIO = 0.18;

    const templates = {
      headline: { w: 1234, h: 1080, guide: 'TW-Slide-Headline_guide.png' },
      avatar:   { w: 400,  h: 400,  guide: 'TW-Avatar_guide.png' },
      sting:    { w: 1920, h: 1080, guide: null },
      panorama: { w: 3562, h: 1075, guide: 'TW-Panorama_guide.png' }
    };

    const layoutGrid = document.getElementById('layoutGrid');

    const fileInput = document.getElementById('fileInput');
    const filePicker = document.getElementById('filePicker');
    const fileNameDisplay = document.getElementById('fileNameDisplay');

    const templateSelect = document.getElementById('templateSelect');

    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const infoBtn = document.getElementById('infoBtn');

    const editorArea = document.getElementById('editor-area');
    const imgElement = document.getElementById('work-image');
    const dropzone = document.getElementById('dropzone');

    const queueWrap = document.getElementById('queueWrap');
    const queueList = document.getElementById('queueList');
    const queueMeta = document.getElementById('queueMeta');

    const panoramaControls = document.getElementById('panoramaControls');
    const panoramaInput = document.getElementById('panoramaInput');
    const panoramaAddBtn = document.getElementById('panoramaAddBtn');

    const blurControls = document.getElementById('blurControls');
    const blurIntensity = document.getElementById('blurIntensity');
    const intensityValue = document.getElementById('intensityValue');
    const blurPlusBtn = document.getElementById('blurPlusBtn');
    const blurMinusBtn = document.getElementById('blurMinusBtn');
    const toggleBlurBtn = document.getElementById('toggleBlurBtn');
    const blurToggleIcon = document.getElementById('blurToggleIcon');

    const customFileNameInput = document.getElementById('customFileName');
    const finalPreview = document.getElementById('finalPreview');

    const downloadBtn = document.getElementById('downloadBtn');
    const resetBtn = document.getElementById('resetBtn');

    const status = document.getElementById('status');

    // ‚úÖ ŸÖŸÜÿπ drag ghost/duplicate ŸÅŸä ŸÉŸÑ ÿßŸÑÿ≠ÿßŸÑÿßÿ™
    imgElement.addEventListener("dragstart", (e) => { e.preventDefault(); });
    editorArea.addEventListener("dragstart", (e) => { e.preventDefault(); });

    function setStatus(html) { status.innerHTML = html || ""; }

    function getBlurStateForIndex(idx) {
      const def = { active:false, left:0, top:0, size:140, intensity:50 };
      if (idx < 0) return def;
      const st = blurStateByIndex.get(idx);
      return st ? { ...def, ...st } : { ...def };
    }

    function setBlurStateForIndex(idx, patch) {
      if (idx < 0) return;
      const cur = getBlurStateForIndex(idx);
      blurStateByIndex.set(idx, { ...cur, ...patch });
    }

    function setLayout(hasQueue) {
      if (hasQueue) {
        layoutGrid.classList.remove("no-queue");
        layoutGrid.classList.add("has-queue");
        queueWrap.style.display = "flex";
        dropzone.style.display = "none";
      } else {
        layoutGrid.classList.add("no-queue");
        layoutGrid.classList.remove("has-queue");
        queueWrap.style.display = "none";
        dropzone.style.display = "flex";
      }
    }

    function formatBytes(bytes) {
      if (!Number.isFinite(bytes)) return "";
      const units = ["B","KB","MB","GB"];
      let i = 0, n = bytes;
      while (n >= 1024 && i < units.length - 1) { n /= 1024; i++; }
      return `${n.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
    }

    function sanitizeBaseName(name) {
      let s = (name || "").trim();
      s = s.replace(/[^a-zA-Z0-9\-_ ]/g, "");
      s = s.replace(/\s+/g, "_");
      return s;
    }

    function getTemplatePrefix() {
      const opt = templateSelect.options[templateSelect.selectedIndex];
      if (!opt) return "";
      const raw = (opt.textContent || "").trim();
      const noParens = raw.replace(/\(.*?\)/g, "").trim();
      const underscored = noParens.replace(/\s+/g, "_").toUpperCase();
      return underscored.replace(/[^A-Z0-9_]/g, "");
    }

    function buildFinalFileName(i1) {
      const prefix = getTemplatePrefix();
      const base = sanitizeBaseName(customFileNameInput.value);
      if (!prefix || !base) return "";
      return `${prefix}_${base}_${i1}.jpg`;
    }

    function updateFinalPreview() {
      const name = buildFinalFileName(Math.max(1, currentIndex + 1));
      finalPreview.textContent = name ? `Example: ${name}` : "Example: TEMPLATE_usa_1.jpg";
    }

    function updateHeaderDisplay() {
      if (imageQueue.length === 0) {
        fileNameDisplay.innerText = "üìÇ CLICK TO UPLOAD IMAGE";
        infoBtn.innerText = "0 / 0";
        return;
      }
      fileNameDisplay.innerText = `‚úÖ ${imageQueue.length} image(s) loaded`;
      infoBtn.innerText = `${currentIndex + 1} / ${imageQueue.length}`;
    }

    function updateNavButtons() {
      const hasQueue = imageQueue.length > 0;
      prevBtn.disabled = !(hasQueue && currentIndex > 0);
      nextBtn.disabled = !(hasQueue && currentIndex < imageQueue.length - 1);
      infoBtn.disabled = !hasQueue;
      infoBtn.style.opacity = hasQueue ? "1" : "0.5";
    }

    function checkPanoramaModeUI() {
      const type = templateSelect.value;
      panoramaControls.style.display = (type === "panorama") ? "block" : "none";
    }

    function setUiBusy(isBusy) {
      fileInput.disabled = isBusy;
      templateSelect.disabled = isBusy;
      customFileNameInput.disabled = isBusy;
      prevBtn.disabled = isBusy || !(imageQueue.length > 0 && currentIndex > 0);
      nextBtn.disabled = isBusy || !(imageQueue.length > 0 && currentIndex < imageQueue.length - 1);
      downloadBtn.disabled = isBusy || downloadBtn.disabled;
      resetBtn.disabled = isBusy;
      panoramaAddBtn.disabled = isBusy;
    }

    function updateDownloadState() {
      const hasQueue = imageQueue.length > 0;
      const hasTemplate = !!templateSelect.value && !!templates[templateSelect.value];
      const hasName = sanitizeBaseName(customFileNameInput.value).length > 0;
      const hasImageLoaded = !!(imgElement.src && imgElement.src !== "");

      downloadBtn.disabled = !(hasQueue && hasTemplate && hasName && hasImageLoaded);
      setLayout(hasQueue);
      updateFinalPreview();
    }

    function renderQueue() {
      if (imageQueue.length === 0) {
        queueList.innerHTML = "";
        queueMeta.innerText = "0 image(s)";
        return;
      }
      queueMeta.innerText = `${imageQueue.length} image(s)`;
      queueList.innerHTML = "";

      imageQueue.forEach((file, idx) => {
        const item = document.createElement("div");
        item.className = "queue-item" + (idx === currentIndex ? " active" : "");

        const left = document.createElement("div");
        left.className = "queue-left";

        const badge = document.createElement("div");
        badge.className = "queue-badge";
        badge.innerText = String(idx + 1);

        const name = document.createElement("div");
        name.className = "queue-name";
        name.innerText = file.name;

        left.appendChild(badge);
        left.appendChild(name);

        const size = document.createElement("div");
        size.className = "queue-size";
        size.innerText = formatBytes(file.size);

        item.appendChild(left);
        item.appendChild(size);

        item.addEventListener("click", () => {
          if (idx !== currentIndex) loadImageAt(idx);
        });

        queueList.appendChild(item);
      });
    }

    function saveCurrentCropState() {
      if (!cropper) return;
      if (currentIndex < 0) return;
      if (!templateSelect.value || !templates[templateSelect.value]) return;

      try {
        cropStateByIndex.set(currentIndex, {
          data: cropper.getData(true),
          cropBoxData: cropper.getCropBoxData(),
          canvasData: cropper.getCanvasData()
        });
      } catch {}
    }

    function restoreCropStateForIndex() {
      if (!cropper) return false;
      const st = cropStateByIndex.get(currentIndex);
      if (!st) return false;
      try {
        cropper.setCanvasData(st.canvasData);
        cropper.setCropBoxData(st.cropBoxData);
        cropper.setData(st.data);
        return true;
      } catch {
        return false;
      }
    }

    function setMaxCropBox(aspectRatio) {
      if (!cropper) return;
      const canvas = cropper.getCanvasData();
      if (!canvas || !canvas.width || !canvas.height) return;

      const padding = 2;
      const maxW = Math.max(0, canvas.width - padding * 2);
      const maxH = Math.max(0, canvas.height - padding * 2);

      let boxW = maxW;
      let boxH = boxW / aspectRatio;

      if (boxH > maxH) {
        boxH = maxH;
        boxW = boxH * aspectRatio;
      }

      const left = canvas.left + (canvas.width - boxW) / 2;
      const top  = canvas.top  + (canvas.height - boxH) / 2;

      cropper.setCropBoxData({ left, top, width: boxW, height: boxH });
    }

    function cleanupObjectURL() {
      if (currentObjectURL) {
        URL.revokeObjectURL(currentObjectURL);
        currentObjectURL = null;
      }
    }

    function waitForCropperReady() {
      return new Promise(resolve => { cropperReadyResolver = resolve; });
    }

    function removeOverlay() {
      document.querySelectorAll('.overlay-ghost').forEach(el => el.remove());
    }

    function updateOverlay(guideImageName) {
      removeOverlay();
      if (!guideImageName) return;

      const viewBox = document.querySelector('.cropper-view-box');
      if (!viewBox) return;

      const img = document.createElement('img');
      img.src = `static/images/${guideImageName}`;
      img.className = 'overlay-ghost';
      img.draggable = false;
      viewBox.style.position = "relative";
      viewBox.appendChild(img);
    }

    function destroyCropper() {
      if (cropper) {
        cropper.destroy();
        cropper = null;
      }
      removeOverlay();
      removeBlurCircle();
    }

    // =========================
    // BLUR per image
    // =========================
    function setBlurBtnUI(active) {
      if (active) {
        toggleBlurBtn.classList.add('active');
        blurToggleIcon.className = 'fas fa-eye';
      } else {
        toggleBlurBtn.classList.remove('active');
        blurToggleIcon.className = 'fas fa-eye-slash';
      }
    }

    function getCropperContainer() {
      return document.querySelector('.cropper-container');
    }

    function ensureBlurCircle() {
      const container = getCropperContainer();
      if (!container) return null;

      let circle = document.getElementById('blur-circle');
      if (circle) return circle;

      circle = document.createElement('div');
      circle.id = 'blur-circle';
      container.appendChild(circle);

      circle.addEventListener('pointerdown', onBlurPointerDown, { passive: false });
      return circle;
    }

    function removeBlurCircle() {
      const circle = document.getElementById('blur-circle');
      if (circle) circle.remove();
    }

    function applyBlurUIFromState() {
      const st = getBlurStateForIndex(currentIndex);

      blurIntensity.value = st.intensity;
      intensityValue.innerText = String(st.intensity);

      const circle = ensureBlurCircle();
      if (!circle) return;

      circle.style.width = st.size + "px";
      circle.style.height = st.size + "px";
      circle.style.left = st.left + "px";
      circle.style.top = st.top + "px";
      circle.style.transform = "none";

      const cssBlur = st.intensity / 10;
      circle.style.backdropFilter = `blur(${cssBlur}px)`;
      circle.style.webkitBackdropFilter = `blur(${cssBlur}px)`;

      circle.style.display = st.active ? "block" : "none";
      setBlurBtnUI(st.active);
    }

    function centerBlurCircleIfNeeded() {
      const st = getBlurStateForIndex(currentIndex);
      const container = getCropperContainer();
      const circle = ensureBlurCircle();
      if (!container || !circle) return;

      const contRect = container.getBoundingClientRect();
      const size = st.size || 140;

      if (!Number.isFinite(st.left) || !Number.isFinite(st.top) || (st.left === 0 && st.top === 0)) {
        const left = Math.max(0, (contRect.width - size) / 2);
        const top  = Math.max(0, (contRect.height - size) / 2);
        setBlurStateForIndex(currentIndex, { left, top, size });
      } else {
        const left = Math.max(0, Math.min(st.left, contRect.width - size));
        const top  = Math.max(0, Math.min(st.top,  contRect.height - size));
        setBlurStateForIndex(currentIndex, { left, top, size });
      }
    }

    function onBlurPointerDown(e) {
      const st = getBlurStateForIndex(currentIndex);
      if (!st.active) return;

      const circle = e.currentTarget;
      const container = getCropperContainer();
      if (!container) return;

      e.preventDefault();
      e.stopPropagation();

      circle.setPointerCapture(e.pointerId);

      blurDrag.active = true;
      blurDrag.startX = e.clientX;
      blurDrag.startY = e.clientY;

      blurDrag.startLeft = parseFloat(circle.style.left || "0");
      blurDrag.startTop  = parseFloat(circle.style.top  || "0");

      window.addEventListener('pointermove', onBlurPointerMove, { passive: false });
      window.addEventListener('pointerup', onBlurPointerUp, { passive: false });
    }

    function onBlurPointerMove(e) {
      if (!blurDrag.active) return;
      e.preventDefault();

      const container = getCropperContainer();
      const circle = document.getElementById('blur-circle');
      if (!container || !circle) return;

      const contRect = container.getBoundingClientRect();
      const size = parseInt(getComputedStyle(circle).width, 10);

      const dx = e.clientX - blurDrag.startX;
      const dy = e.clientY - blurDrag.startY;

      let newLeft = blurDrag.startLeft + dx;
      let newTop  = blurDrag.startTop  + dy;

      newLeft = Math.max(0, Math.min(newLeft, contRect.width - size));
      newTop  = Math.max(0, Math.min(newTop,  contRect.height - size));

      circle.style.left = newLeft + 'px';
      circle.style.top  = newTop  + 'px';
    }

    function onBlurPointerUp() {
      blurDrag.active = false;
      window.removeEventListener('pointermove', onBlurPointerMove);
      window.removeEventListener('pointerup', onBlurPointerUp);

      const circle = document.getElementById('blur-circle');
      if (!circle) return;
      const left = parseFloat(circle.style.left || "0");
      const top  = parseFloat(circle.style.top  || "0");
      const size = parseInt(getComputedStyle(circle).width, 10) || 140;
      setBlurStateForIndex(currentIndex, { left, top, size });
    }

    function updateBlurIntensity(val) {
      intensityValue.innerText = val;
      setBlurStateForIndex(currentIndex, { intensity: parseInt(val, 10) });

      const circle = document.getElementById('blur-circle');
      if (!circle) return;

      const cssBlur = val / 10;
      circle.style.backdropFilter = `blur(${cssBlur}px)`;
      circle.style.webkitBackdropFilter = `blur(${cssBlur}px)`;
    }

    function resizeBlur(delta) {
      const st = getBlurStateForIndex(currentIndex);
      if (!st.active) return;

      const container = getCropperContainer();
      const circle = document.getElementById('blur-circle');
      if (!container || !circle) return;

      const contRect = container.getBoundingClientRect();
      let size = parseInt(getComputedStyle(circle).width, 10) || 140;
      size = size + delta;

      if (size < 30) size = 30;
      if (size > Math.min(contRect.width, contRect.height)) size = Math.min(contRect.width, contRect.height);

      const left = parseFloat(circle.style.left || "0");
      const top  = parseFloat(circle.style.top  || "0");
      const oldSize = parseInt(getComputedStyle(circle).width, 10) || 140;
      const cx = left + oldSize / 2;
      const cy = top  + oldSize / 2;

      let newLeft = cx - size / 2;
      let newTop  = cy - size / 2;

      newLeft = Math.max(0, Math.min(newLeft, contRect.width - size));
      newTop  = Math.max(0, Math.min(newTop,  contRect.height - size));

      circle.style.width = size + 'px';
      circle.style.height = size + 'px';
      circle.style.left = newLeft + 'px';
      circle.style.top  = newTop  + 'px';

      setBlurStateForIndex(currentIndex, { size, left: newLeft, top: newTop });
    }

    function toggleBlur() {
      const st = getBlurStateForIndex(currentIndex);
      const newActive = !st.active;
      setBlurStateForIndex(currentIndex, { active: newActive });

      const circle = ensureBlurCircle();
      if (!circle) return;

      if (newActive) {
        centerBlurCircleIfNeeded();
        applyBlurUIFromState();
      } else {
        circle.style.display = "none";
        setBlurBtnUI(false);
      }
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }

    function applyBlurFeatherToFinalCanvas(finalCanvas, outW, outH, blurState) {
      if (!blurState || !blurState.active) return finalCanvas;

      const container = getCropperContainer();
      if (!container || !cropper) return finalCanvas;

      const cropBox = cropper.getCropBoxData();
      if (!cropBox || !cropBox.width || !cropBox.height) return finalCanvas;

      const cx = blurState.left + (blurState.size / 2);
      const cy = blurState.top  + (blurState.size / 2);
      const r  = blurState.size / 2;

      let u = (cx - cropBox.left) / cropBox.width;
      let v = (cy - cropBox.top ) / cropBox.height;
      u = clamp01(u); v = clamp01(v);

      const rrX = r / cropBox.width;
      const rrY = r / cropBox.height;

      const outCx = u * outW;
      const outCy = v * outH;
      const outR  = ((rrX * outW) + (rrY * outH)) / 2;

      const strength = parseInt(blurState.intensity || 50, 10);
      const blurPx = Math.max(3, Math.round(strength / 6));

      const ctx = finalCanvas.getContext('2d');

      const base = document.createElement('canvas');
      base.width = outW;
      base.height = outH;
      base.getContext('2d').drawImage(finalCanvas, 0, 0);

      const blurred = document.createElement('canvas');
      blurred.width = outW;
      blurred.height = outH;
      const bctx = blurred.getContext('2d');
      bctx.filter = `blur(${blurPx}px)`;
      bctx.drawImage(base, 0, 0);
      bctx.filter = 'none';

      const mask = document.createElement('canvas');
      mask.width = outW;
      mask.height = outH;
      const mctx = mask.getContext('2d');

      const inner = Math.max(0, outR * (1 - FEATHER_RATIO));
      const outer = outR;

      const grad = mctx.createRadialGradient(outCx, outCy, inner, outCx, outCy, outer);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');

      mctx.fillStyle = grad;
      mctx.fillRect(0, 0, outW, outH);

      const blurMasked = document.createElement('canvas');
      blurMasked.width = outW;
      blurMasked.height = outH;
      const bm = blurMasked.getContext('2d');
      bm.drawImage(blurred, 0, 0);
      bm.globalCompositeOperation = 'destination-in';
      bm.drawImage(mask, 0, 0);
      bm.globalCompositeOperation = 'source-over';

      ctx.clearRect(0, 0, outW, outH);
      ctx.drawImage(base, 0, 0);
      ctx.drawImage(blurMasked, 0, 0);

      return finalCanvas;
    }

    blurIntensity.addEventListener("input", (e) => updateBlurIntensity(e.target.value));
    blurPlusBtn.addEventListener("click", () => resizeBlur(10));
    blurMinusBtn.addEventListener("click", () => resizeBlur(-10));
    toggleBlurBtn.addEventListener("click", toggleBlur);

    // =========================
    // ‚úÖ PANORAMA STITCHING (GitHub-friendly)
    // =========================
    async function fileToBitmap(file) {
      return await createImageBitmap(file);
    }

    async function stitchPanoramaFilesToBlob(files, outW = 3562, outH = 1075, quality = 0.92) {
      if (!files || files.length < 2) return null;

      const bitmaps = [];
      for (const f of files) bitmaps.push(await fileToBitmap(f));

      // ŸÜÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿßŸÑŸÜÿ≥ÿ®: ŸÜÿ´ÿ®ÿ™ ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ outH ŸàŸÜÿ≠ÿ≥ÿ® ÿπÿ±ÿ∂ ŸÉŸÑ ÿµŸàÿ±ÿ©
      const widths = bitmaps.map(b => Math.max(1, Math.round((b.width / b.height) * outH)));
      const totalW = widths.reduce((a, b) => a + b, 0);

      // scale ŸÑŸäÿ∑ÿßÿ®ŸÇ outW
      const scale = outW / totalW;

      const canvas = document.createElement("canvas");
      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, outW, outH);

      let x = 0;
      for (let i = 0; i < bitmaps.length; i++) {
        const bmp = bitmaps[i];
        const w = Math.max(1, Math.round(widths[i] * scale));
        ctx.drawImage(bmp, 0, 0, bmp.width, bmp.height, x, 0, w, outH);
        x += w;
      }

      return await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg", quality));
    }

    async function renderPanoramaPreviewForCurrentIndex() {
      if (currentIndex < 0) return;

      const files = panoramaFilesByIndex.get(currentIndex) || [imageQueue[currentIndex]];
      if (!files || files.length < 2) {
        setStatus('<span style="color:#fbbf24;">‚ö†Ô∏è ÿ£ÿ∂ŸÅ ÿµŸàÿ±ÿ™ŸäŸÜ ÿ£Ÿà ÿ£ŸÉÿ´ÿ± ŸÑŸÑÿ®ÿßŸÜŸàÿ±ÿßŸÖÿß ÿ≠ÿ™Ÿâ ŸäÿµŸäÿ± ÿØŸÖÿ¨.</span>');
        return;
      }

      setUiBusy(true);
      setStatus(`‚è≥ Stitching Panorama... (${files.length} images)`);

      try {
        const blob = await stitchPanoramaFilesToBlob(files, 3562, 1075, 0.92);
        if (!blob) throw new Error("Stitch failed");

        const old = panoramaRenderedURLByIndex.get(currentIndex);
        if (old) URL.revokeObjectURL(old);

        const url = URL.createObjectURL(blob);
        panoramaRenderedURLByIndex.set(currentIndex, url);

        destroyCropper();
        cleanupObjectURL();

        imgElement.src = url;
        imgElement.onload = () => {
          initCropper();
          setUiBusy(false);
          setStatus(`<span style="color:#4ade80;">‚úÖ Panorama stitched (${files.length} images)</span>`);
        };
      } catch (e) {
        console.error(e);
        setUiBusy(false);
        setStatus('<span style="color:#f87171;">‚ùå ŸÅÿ¥ŸÑ ÿØŸÖÿ¨ ÿßŸÑÿ®ÿßŸÜŸàÿ±ÿßŸÖÿß. ÿ¨ÿ±Ÿëÿ® ÿµŸàÿ± ÿ£ŸÇŸÑ ÿ£Ÿà ÿ£ÿ≠ÿ¨ÿßŸÖ ÿ£ÿµÿ∫ÿ±.</span>');
      }
    }

    // =========================
    // CROP INIT
    // =========================
    function initCropper() {
      const type = templateSelect.value;
      const settings = templates[type];
      if (!settings) return;

      destroyCropper();

      cropper = new Cropper(imgElement, {
        aspectRatio: settings.w / settings.h,
        viewMode: 1,
        dragMode: 'crop',
        cropBoxMovable: true,
        cropBoxResizable: true,
        toggleDragModeOnDblclick: false,
        autoCropArea: 0.95,
        background: false,
        guides: false,
        center: false,
        ready() {
          blurControls.style.display = 'flex';

          updateOverlay(settings.guide);

          const restored = restoreCropStateForIndex();
          if (!restored) setMaxCropBox(settings.w / settings.h);

          centerBlurCircleIfNeeded();
          applyBlurUIFromState();

          checkPanoramaModeUI();
          updateHeaderDisplay();
          updateNavButtons();
          renderQueue();
          updateDownloadState();

          if (cropperReadyResolver) { const r = cropperReadyResolver; cropperReadyResolver = null; r(); }
        }
      });
    }

    function loadImageAt(index) {
      if (index < 0 || index >= imageQueue.length) return;

      saveCurrentCropState();
      currentIndex = index;

      // ‚úÖ ÿ•ÿ∞ÿß ÿπŸÜÿØŸä ÿ®ÿßŸÜŸàÿ±ÿßŸÖÿß ŸÖÿØŸÖŸàÿ¨ÿ© ŸÑŸáÿ∞Ÿä ÿßŸÑÿµŸàÿ±ÿ©ÿå ÿßÿπÿ±ÿ∂Ÿáÿß ÿ®ÿØŸÑ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ£ÿµŸÑŸä
      if (templateSelect.value === "panorama") {
        const stitchedURL = panoramaRenderedURLByIndex.get(currentIndex);
        if (stitchedURL) {
          destroyCropper();
          cleanupObjectURL();
          imgElement.src = stitchedURL;

          imgElement.onload = () => {
            initCropper();
            if (cropperReadyResolver) { const r = cropperReadyResolver; cropperReadyResolver = null; r(); }
          };

          updateHeaderDisplay();
          updateNavButtons();
          renderQueue();
          updateDownloadState();
          updateFinalPreview();
          return;
        }
      }

      cleanupObjectURL();

      const file = imageQueue[currentIndex];
      currentObjectURL = URL.createObjectURL(file);

      setStatus("");
      imgElement.src = currentObjectURL;

      imgElement.onload = () => {
        if (templateSelect.value && templates[templateSelect.value]) {
          initCropper();
        } else {
          destroyCropper();
          blurControls.style.display = 'none';
          updateHeaderDisplay();
          updateNavButtons();
          renderQueue();
          updateDownloadState();
          if (cropperReadyResolver) { const r = cropperReadyResolver; cropperReadyResolver = null; r(); }
        }
      };

      updateHeaderDisplay();
      updateNavButtons();
      renderQueue();
      updateDownloadState();
      updateFinalPreview();
    }

    function fileKey(f) {
      return `${f.name}__${f.size}__${f.lastModified || 0}`;
    }

    function processSelectedFiles(fileList) {
      const files = Array.from(fileList || []);
      if (!files.length) return;

      const onlyImages = files.filter(f => f.type && f.type.startsWith("image/"));
      if (!onlyImages.length) {
        setStatus('<span style="color:#f87171;">‚ùå No valid images selected.</span>');
        return;
      }

      const existingKeys = new Set(imageQueue.map(fileKey));
      const newOnes = [];

      for (const f of onlyImages) {
        const k = fileKey(f);
        if (!existingKeys.has(k)) {
          existingKeys.add(k);
          newOnes.push(f);
        }
      }

      if (!newOnes.length) {
        setStatus('<span style="color:#fbbf24;">‚ö†Ô∏è These images are already in the queue.</span>');
        return;
      }

      const wasEmpty = (imageQueue.length === 0);
      imageQueue = imageQueue.concat(newOnes);

      for (let i = imageQueue.length - newOnes.length; i < imageQueue.length; i++) {
        panoramaFilesByIndex.set(i, [imageQueue[i]]);
        blurStateByIndex.set(i, { active:false, left:0, top:0, size:140, intensity:50 });
      }

      if (wasEmpty) {
        cropStateByIndex.clear();
        currentIndex = 0;

        setLayout(true);
        dropzone.style.display = "none";

        updateHeaderDisplay();
        updateNavButtons();
        renderQueue();
        updateFinalPreview();
        updateDownloadState();

        loadImageAt(0);
      } else {
        updateHeaderDisplay();
        updateNavButtons();
        renderQueue();
        updateFinalPreview();
        updateDownloadState();
        setStatus(`<span style="color:#4ade80;">‚úÖ Added ${newOnes.length} image(s) to queue</span>`);
      }
    }

    function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

    ["dragenter","dragover","dragleave","drop"].forEach(evt => {
      dropzone.addEventListener(evt, preventDefaults, false);
      editorArea.addEventListener(evt, preventDefaults, false);
    });

    ["dragenter","dragover"].forEach(evt => {
      dropzone.addEventListener(evt, () => dropzone.classList.add("dragover"), false);
      editorArea.addEventListener(evt, () => dropzone.classList.add("dragover"), false);
    });

    ["dragleave","drop"].forEach(evt => {
      dropzone.addEventListener(evt, () => dropzone.classList.remove("dragover"), false);
      editorArea.addEventListener(evt, () => dropzone.classList.remove("dragover"), false);
    });

    function handleDropFiles(e) {
      const dt = e.dataTransfer;
      if (!dt) return;
      processSelectedFiles(dt.files);
    }

    editorArea.addEventListener("drop", handleDropFiles);
    dropzone.addEventListener("drop", handleDropFiles);

    dropzone.addEventListener("click", () => fileInput.click());
    filePicker.addEventListener("click", () => fileInput.click());

    fileInput.addEventListener("change", (e) => {
      processSelectedFiles(e.target.files);
      fileInput.value = "";
    });

    templateSelect.addEventListener("change", async () => {
      const type = templateSelect.value;

      if (type === "webscroll") {
        // GitHub Pages: ÿßŸÅÿ™ÿ≠ cleaner.html ÿ®ÿØŸÑ /cleaner
        window.location.href = "cleaner.html";
        return;
      }

      saveCurrentCropState();
      checkPanoramaModeUI();

      // ÿ•ÿ∞ÿß ÿ®ÿßŸÜŸàÿ±ÿßŸÖÿß ŸàŸÖŸàÿ¨ŸàÿØ ŸÖŸÑŸÅÿßÿ™ ÿßÿ∂ÿßŸÅŸäÿ©: ÿßÿπŸÖŸÑ render ÿ™ŸÑŸÇÿßÿ¶Ÿä
      if (type === "panorama" && currentIndex >= 0) {
        const arr = panoramaFilesByIndex.get(currentIndex) || [];
        if (arr.length >= 2) {
          await renderPanoramaPreviewForCurrentIndex();
          updateDownloadState();
          updateFinalPreview();
          return;
        }
      }

      if (imageQueue.length && currentIndex >= 0 && imgElement.src) {
        if (type && templates[type]) {
          initCropper();
        } else {
          destroyCropper();
          blurControls.style.display = 'none';
        }
      }

      updateDownloadState();
      updateFinalPreview();
    });

    prevBtn.addEventListener("click", () => {
      if (currentIndex > 0) loadImageAt(currentIndex - 1);
    });

    nextBtn.addEventListener("click", () => {
      if (currentIndex < imageQueue.length - 1) loadImageAt(currentIndex + 1);
    });

    // Panorama
    panoramaAddBtn.addEventListener("click", () => panoramaInput.click());

    panoramaInput.addEventListener("change", async () => {
      const files = Array.from(panoramaInput.files || []).filter(f => f.type && f.type.startsWith("image/"));
      panoramaInput.value = "";
      if (!files.length) return;

      if (currentIndex < 0 || currentIndex >= imageQueue.length) {
        setStatus('<span style="color:#f87171;">‚ùå Load an image first.</span>');
        return;
      }

      const type = templateSelect.value;
      if (type !== "panorama") {
        setStatus('<span style="color:#fbbf24;">‚ö†Ô∏è Panorama template must be selected.</span>');
        return;
      }

      const arr = panoramaFilesByIndex.get(currentIndex) || [imageQueue[currentIndex]];
      files.forEach(f => arr.push(f));
      panoramaFilesByIndex.set(currentIndex, arr);

      await renderPanoramaPreviewForCurrentIndex();
    });

    function downloadBlob(blob, finalFileNameWithExt) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = finalFileNameWithExt;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function canvasToBlob(canvas, quality=0.9) {
      return new Promise(resolve => canvas.toBlob(b => resolve(b), "image/jpeg", quality));
    }

    async function exportCurrentToBlob() {
      const type = templateSelect.value;
      const settings = templates[type];
      if (!settings) throw new Error("Template not selected");
      if (!cropper) throw new Error("Cropper not ready");

      let finalCanvas = cropper.getCroppedCanvas({
        width: settings.w,
        height: settings.h,
        fillColor: '#fff',
        imageSmoothingEnabled: true,
        imageSmoothingQuality: 'medium'
      });

      if (!finalCanvas) throw new Error("Canvas generation failed");

      const st = getBlurStateForIndex(currentIndex);
      finalCanvas = applyBlurFeatherToFinalCanvas(finalCanvas, settings.w, settings.h, st);

      return await canvasToBlob(finalCanvas, 0.90);
    }

    downloadBtn.addEventListener("click", async () => {
      try {
        if (!imageQueue.length) return;

        const type = templateSelect.value;
        if (!type || !templates[type]) {
          setStatus('<span style="color:#fbbf24;">‚ö†Ô∏è Select template first.</span>');
          return;
        }

        const base = sanitizeBaseName(customFileNameInput.value);
        if (!base) {
          setStatus('<span style="color:#fbbf24;">‚ö†Ô∏è Enter base name first.</span>');
          return;
        }

        setUiBusy(true);
        const originalText = downloadBtn.innerHTML;
        downloadBtn.innerHTML = 'Processing All... <i class="fas fa-spinner fa-spin"></i>';
        downloadBtn.disabled = true;

        setStatus(`‚è≥ Exporting ${imageQueue.length} image(s)...`);

        for (let i = 0; i < imageQueue.length; i++) {
          loadImageAt(i);
          await waitForCropperReady();

          const finalFileName = buildFinalFileName(i + 1);
          setStatus(`‚è≥ (${i + 1}/${imageQueue.length}) Generating: <b>${finalFileName}</b> ...`);

          const blob = await exportCurrentToBlob();
          downloadBlob(blob, finalFileName);

          await new Promise(r => setTimeout(r, 180));
        }

        downloadBtn.innerHTML = originalText;
        setUiBusy(false);

        setStatus(`<span style="color:#4ade80;">‚úÖ Downloaded all: ${imageQueue.length} file(s)</span>`);
        updateDownloadState();

      } catch (err) {
        console.error(err);
        setUiBusy(false);
        downloadBtn.innerHTML = 'Download All <i class="fas fa-arrow-down"></i>';
        setStatus(`<span style="color:#f87171;">‚ùå ${String(err.message || err)}</span>`);
        updateDownloadState();
      }
    });

    resetBtn.addEventListener("click", () => {
      destroyCropper();
      cleanupObjectURL();

      // ‚úÖ ÿ™ŸÜÿ∏ŸäŸÅ panorama cached URLs
      for (const url of panoramaRenderedURLByIndex.values()) {
        try { URL.revokeObjectURL(url); } catch {}
      }
      panoramaRenderedURLByIndex.clear();

      imageQueue = [];
      currentIndex = -1;
      cropStateByIndex.clear();
      panoramaFilesByIndex.clear();
      blurStateByIndex.clear();

      fileInput.value = "";
      panoramaInput.value = "";

      blurControls.style.display = "none";
      blurIntensity.value = 50;
      intensityValue.innerText = "50";

      templateSelect.selectedIndex = 0;
      customFileNameInput.value = "";

      imgElement.src = "";
      fileNameDisplay.innerText = "üìÇ CLICK TO UPLOAD IMAGE";

      setStatus("");
      updateHeaderDisplay();
      updateNavButtons();
      renderQueue();
      checkPanoramaModeUI();
      updateDownloadState();
    });

    customFileNameInput.addEventListener("input", updateDownloadState);

    // =========================
    // init
    // =========================
    function waitForCropperReady() {
      return new Promise(resolve => { cropperReadyResolver = resolve; });
    }

    window.addEventListener("DOMContentLoaded", () => {
      editorArea.style.display = "block";
      setLayout(false);
      updateHeaderDisplay();
      updateNavButtons();
      renderQueue();
      checkPanoramaModeUI();
      updateDownloadState();
      updateFinalPreview();
    });
  </script>
</body>
</html>
