<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Newsroom Tool - Unified (Mixer)</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

  <style>
    * { box-sizing: border-box; }

    body{
      margin:0; padding:0;
      color:#fff;
      font-family: Inter, sans-serif;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.85)),
                  url('static/images/background-image.png') no-repeat center center fixed;
      background-size: cover;
      overflow-x:hidden;
    }

    .home-btn {
      position:absolute; top:30px; left:30px;
      text-decoration:none; color:#fff;
      background: rgba(255,255,255,0.1);
      padding:10px 20px;
      border-radius:30px;
      display:flex; align-items:center; gap:10px;
      font-weight:800;
      font-family:'Tajawal', sans-serif;
      border:1px solid rgba(255,255,255,0.2);
      transition:0.3s;
      z-index:2000;
      backdrop-filter: blur(6px);
    }
    .home-btn:hover{
      background: rgba(255,255,255,0.2);
      transform: scale(1.05);
      border-color:#2ecc71;
      color:#fff;
    }

    nav{
      display:flex;
      justify-content:space-between;
      align-items:center;
      width:90%;
      max-width:1200px;
      padding:25px 0;
      z-index:10;
      margin-bottom:10px;
    }
    .logo-img{ height:70px; width:auto; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5)); }
    .version-badge{
      background: rgba(255,255,255,0.1);
      padding:5px 12px;
      border-radius:20px;
      font-size:0.85rem;
      border:1px solid rgba(255,255,255,0.2);
      color:#ccc;
      font-family:'Tajawal', sans-serif;
      font-weight:700;
    }

    .glass-container{
      width:90%;
      max-width:1200px;
      background: rgba(20,20,20,0.65);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:24px;
      padding:28px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.6);
      margin-bottom:50px;
    }

    /* ===== Layout: Main + Queue on RIGHT ===== */
    .layout{
      display:grid;
      grid-template-columns: 1fr 330px; /* queue on right */
      gap:18px;
      align-items:start;
    }
    @media (max-width: 1050px){
      .layout{
        grid-template-columns: 1fr;
      }
    }

    .main-panel{ min-width:0; }

    .controls-grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(260px, 1fr));
      gap:18px;
      margin-bottom:14px;
    }
    @media (max-width: 850px){
      .controls-grid{ grid-template-columns: 1fr; }
    }

    label{
      display:block;
      margin-bottom:10px;
      font-weight:800;
      color:#e2e8f0;
      font-size:0.95rem;
      text-transform:uppercase;
      letter-spacing:0.5px;
      font-family:'Tajawal', sans-serif;
    }

    select, .custom-file-upload, input[type="text"]{
      width:100%;
      background: rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.22);
      color:#fff;
      padding:14px 14px;
      border-radius:12px;
      font-size:1rem;
      outline:none;
      transition:0.25s;
      font-family:'Tajawal', sans-serif;
      font-weight:700;
    }
    select:hover, .custom-file-upload:hover, input[type="text"]:focus{
      border-color:#3b82f6;
      background: rgba(59,130,246,0.12);
    }
    .custom-file-upload{
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    #fileNameDisplay{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:100%;
      direction:ltr;
      display:inline-block;
    }
    input[type="file"]{ display:none; }
    option{ background-color:#1a1a1a; color:#fff; }
    option.has-guide{
      color:#ff6b6b;
      font-weight:900;
      background-color:#2d1b1b;
    }
    optgroup{
      font-weight:900;
      color:#94a3b8;
      background-color:#0f0f0f;
      font-family:'Tajawal', sans-serif;
    }

    /* ===== Dropzone (shown when no images) ===== */
    .dropzone{
      height: 540px;
      border-radius: 16px;
      border: 1px dashed rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.25);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      margin-top:10px;
    }
    .dropzone-inner{
      width: min(520px, 92%);
      padding: 28px 18px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.45);
      text-align:center;
      box-shadow: 0 12px 40px rgba(0,0,0,0.45);
    }
    .drop-icon{
      width:56px; height:56px;
      border-radius: 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      margin:0 auto 12px auto;
      background: rgba(59,130,246,0.16);
      border:1px solid rgba(59,130,246,0.35);
    }
    .drop-title{
      font-family:'Tajawal', sans-serif;
      font-size: 20px;
      font-weight: 900;
      margin: 0 0 6px 0;
    }
    .drop-sub{
      font-family:'Tajawal', sans-serif;
      font-size: 14px;
      color: rgba(255,255,255,0.75);
      margin: 0 0 12px 0;
      line-height: 1.6;
    }
    .drop-tip{
      font-family:'Tajawal', sans-serif;
      font-size: 12px;
      color: rgba(255,255,255,0.55);
      margin: 0;
    }
    .dropzone.dragover{
      border-color: rgba(46, 204, 113, 0.9);
      box-shadow: 0 0 0 3px rgba(46,204,113,0.25) inset;
    }

    /* ===== Editor Window ===== */
    .img-window{
      height: 540px;
      background-color:#0a0a0a;
      border-radius:16px;
      overflow:hidden;
      position:relative;
      border:1px dashed rgba(255,255,255,0.2);
      display:none; /* shown when images exist */
      align-items:center;
      justify-content:center;
      margin-top:10px;
    }
    #image{ max-width:100%; display:block; }

    /* Cropper styles */
    .cropper-face{ background-color: transparent !important; opacity:1 !important; }
    .cropper-point{ z-index: 100 !important; background-color:#3b82f6; width:10px; height:10px; }
    .cropper-view-box{ outline:2px solid #3b82f6; }
    .cropper-dashed, .cropper-line { display:none !important; }

    /* Overlay must fill the crop box */
    .overlay-ghost{
      position:absolute;
      top:0; left:0;
      width:100% !important;
      height:100% !important;
      z-index:50;
      pointer-events:none !important;
      opacity:1 !important;
      display:block !important;
      object-fit: contain;
    }

    /* ===== Nav buttons ===== */
    .nav-row{
      display:flex;
      gap:10px;
      margin-top:12px;
      align-items:center;
    }
    .nav-btn{
      flex:1;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      color:#fff;
      padding: 12px 14px;
      border-radius: 12px;
      font-family:'Tajawal', sans-serif;
      font-weight:900;
      cursor:pointer;
      transition:0.2s;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
    }
    .nav-btn:hover{ background: rgba(255,255,255,0.14); transform: translateY(-1px); }
    .nav-btn:disabled{
      opacity:0.45;
      cursor:not-allowed;
      transform:none;
    }
    .nav-mid{
      width: 190px;
      min-width: 190px;
      text-align:center;
      padding: 12px 10px;
      border-radius:12px;
      background: rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.14);
      font-family:'Tajawal', sans-serif;
      font-weight:900;
      color: rgba(255,255,255,0.88);
    }

    .filename-section{ margin-top:16px; }
    .filename-hint{
      margin-top:8px;
      font-size: 12px;
      color: rgba(255,255,255,0.55);
      font-family:'Tajawal', sans-serif;
      direction:ltr;
      text-align:left;
    }

    .btn-save{
      margin-top:14px;
      background: linear-gradient(135deg,#e2e8f0 0%,#cbd5e1 100%);
      color:#0f172a;
      border:none;
      padding: 16px 20px;
      border-radius: 12px;
      font-size: 1.05rem;
      font-weight: 900;
      cursor:pointer;
      width:100%;
      transition:0.25s;
      font-family:'Tajawal', sans-serif;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
    }
    .btn-save:hover{
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255,255,255,0.18);
      background:#fff;
    }
    .btn-save:disabled{
      background:#444;
      color:#888;
      cursor:not-allowed;
      transform:none;
      box-shadow:none;
      opacity:0.9;
    }

    #status{ margin-top:14px; text-align:center; min-height: 28px; }
    .success{
      color:#4ade80;
      background: rgba(74,222,128,0.1);
      padding:10px 16px;
      border-radius: 10px;
      border:1px solid #4ade80;
      display:inline-block;
      font-family:'Tajawal', sans-serif;
      font-weight:800;
    }
    .error{
      color:#f87171;
      background: rgba(248,113,113,0.1);
      padding:10px 16px;
      border-radius: 10px;
      border:1px solid #f87171;
      display:inline-block;
      font-family:'Tajawal', sans-serif;
      font-weight:800;
    }

    /* ===== Queue Panel ===== */
    .queue-panel{
      background: rgba(0,0,0,0.32);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      padding: 14px;
      position: sticky;
      top: 18px;
      max-height: calc(100vh - 170px);
      overflow:auto;
    }
    .queue-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom: 12px;
      gap:10px;
    }
    .queue-title{
      font-family:'Tajawal', sans-serif;
      font-weight: 900;
      letter-spacing: 0.3px;
      color: rgba(255,255,255,0.92);
    }
    .queue-count{
      font-family:'Tajawal', sans-serif;
      font-weight: 900;
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
      padding:6px 10px;
      border-radius: 999px;
      white-space:nowrap;
    }
    .queue-list{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .queue-item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      cursor:pointer;
      transition:0.2s;
      user-select:none;
    }
    .queue-item:hover{
      background: rgba(255,255,255,0.06);
      transform: translateY(-1px);
    }
    .queue-item.active{
      border-color: rgba(46, 204, 113, 0.85);
      box-shadow: 0 0 0 2px rgba(46,204,113,0.18) inset;
      background: rgba(46,204,113,0.10);
    }
    .qi-left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .qi-badge{
      width: 28px;
      height: 28px;
      border-radius: 10px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: 'Inter', sans-serif;
      font-weight: 900;
      background: rgba(255,255,255,0.1);
      border:1px solid rgba(255,255,255,0.15);
      flex: 0 0 auto;
    }
    .qi-name{
      font-family:'Tajawal', sans-serif;
      font-weight: 800;
      font-size: 13px;
      color: rgba(255,255,255,0.9);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 180px;
      direction:ltr;
    }
    .qi-size{
      font-family:'Tajawal', sans-serif;
      font-weight: 800;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      flex: 0 0 auto;
      direction:ltr;
    }
  </style>
</head>

<body>
  <a href="index.html" class="home-btn"><i class="fas fa-home"></i> ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</a>

  <nav>
    <img src="static/images/logo.png" alt="Channel Logo" class="logo-img">
    <div class="version-badge">ÿßŸÑÿ™ŸÑŸÅÿ≤ŸäŸàŸÜ ÿßŸÑÿπÿ±ÿ®Ÿä</div>
  </nav>

  <div class="glass-container">
    <div class="layout">
      <!-- MAIN -->
      <div class="main-panel">
        <div class="controls-grid">
          <div>
            <label>1. Source Image</label>
            <label class="custom-file-upload" id="uploadBtn">
              <input type="file" id="uploadInput" accept="image/*" multiple>
              <span id="fileNameDisplay">üìÇ Click / Drop Images</span>
              <i class="fa-solid fa-cloud-arrow-up"></i>
            </label>
          </div>
          <div>
            <label>2. Select Template</label>
            <select id="templateSelector">
              <option value="" data-w="" data-h="">-- Select Format --</option>

              <optgroup label="GUIDE (Red Zones)">
                <option class="has-guide" value="static/images/KEYPOINT.png" data-w="654" data-h="1024" data-mode="wave">KEYPOINT LOGO</option>
                <option class="has-guide" value="static/images/phono_guide.png" data-w="853" data-h="1024">PHONO</option>
                <option class="has-guide" value="static/images/KEYPOINT.png" data-w="654" data-h="1024">KEYPOINT</option>
                <option class="has-guide" value="static/images/AK HEADLINE.png" data-w="1024" data-h="616">AK HEADLINE</option>
                <option class="has-guide" value="static/images/LK.png" data-w="1024" data-h="1024">LK</option>
              </optgroup>

              <optgroup label="NO GUIDE (Clean)">
                <option value="" data-w="1024" data-h="746">V.WALL B</option>
                <option value="" data-w="1920" data-h="1080">TOPICAL STING</option>
                <option value="" data-w="743" data-h="1024">V.WALL G</option>
                <option value="" data-w="1152" data-h="1944">V.WALL A</option>
                <option value="" data-w="660" data-h="1024">BIG IMAGE</option>
                <option value="" data-w="1024" data-h="770">SMALL IMAGE</option>
              </optgroup>
            </select>
          </div>
        </div>

        <!-- Dropzone (before upload) -->
        <div class="dropzone" id="dropzone">
          <div class="dropzone-inner">
            <div class="drop-icon"><i class="fa-solid fa-cloud-arrow-up"></i></div>
            <p class="drop-title">ÿßÿ±ŸÅÿπ ÿßŸÑÿµŸàÿ± ÿ≠ÿ™Ÿâ ŸÜÿ®ÿØÿ£</p>
            <p class="drop-sub">ÿßÿ≥ÿ≠ÿ® ÿßŸÑÿµŸàÿ± Ÿàÿ£ÿ≥ŸÇÿ∑Ÿáÿß ŸáŸÜÿß ÿ£Ÿà ÿßÿ∂ÿ∫ÿ∑ ŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿπÿØÿ© ÿµŸàÿ± ÿØŸÅÿπÿ© Ÿàÿßÿ≠ÿØÿ©</p>
            <p class="drop-tip">Tip: Drag & Drop Ÿäÿ∂ŸäŸÅ ÿµŸàÿ± ŸÑŸÑŸÄ Queue ÿ®ÿØŸàŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÇÿØŸäŸÖÿ©</p>
          </div>
        </div>

        <!-- Editor -->
        <div class="img-window" id="editorWindow">
          <img id="image" src="" alt="">
        </div>

        <!-- Nav -->
        <div class="nav-row" id="navRow" style="display:none;">
          <button class="nav-btn" id="prevBtn"><i class="fa-solid fa-arrow-left"></i> Previous</button>
          <div class="nav-mid" id="navInfo">0 / 0</div>
          <button class="nav-btn" id="nextBtn">Next <i class="fa-solid fa-arrow-right"></i></button>
        </div>

        <!-- Base name -->
        <div class="filename-section">
          <label for="customFileName">3. BASE NAME (WRITE ONCE):</label>
          <input type="text" id="customFileName" placeholder="Type base name (e.g. usa)...">
          <div class="filename-hint" id="nameExample">Example: TEMPLATE_usa.jpg</div>
        </div>

        <button id="downloadAllBtn" class="btn-save" disabled><i class="fa-solid fa-download"></i> Download All</button>
        <div id="status"></div>
      </div>

      <!-- QUEUE -->
      <aside class="queue-panel" id="queuePanel">
        <div class="queue-header">
          <div class="queue-title">Queue</div>
          <div class="queue-count" id="queueCount">0 image(s)</div>
        </div>
        <div class="queue-list" id="queueList"></div>
      </aside>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

  <script>
    const imageEl = document.getElementById('image');
    const inputEl = document.getElementById('uploadInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const templateSelector = document.getElementById('templateSelector');
    const statusEl = document.getElementById('status');
    const fileNameDisplay = document.getElementById('fileNameDisplay');
    const baseNameEl = document.getElementById('customFileName');
    const downloadAllBtn = document.getElementById('downloadAllBtn');

    const dropzone = document.getElementById('dropzone');
    const editorWindow = document.getElementById('editorWindow');
    const navRow = document.getElementById('navRow');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const navInfo = document.getElementById('navInfo');

    const queueList = document.getElementById('queueList');
    const queueCount = document.getElementById('queueCount');
    const nameExample = document.getElementById('nameExample');

    let cropper = null;

    let currentWidth = 0;
    let currentHeight = 0;

    // Queue state
    const queue = []; // { file, url, name, sizeText, state:{ canvasData, cropBoxData, data }, loaded:bool }
    let currentIndex = -1;

    function bytesToMB(bytes){
      const mb = bytes / (1024*1024);
      return (mb < 10 ? mb.toFixed(1) : mb.toFixed(0)) + " MB";
    }

    function getTemplateSettings(){
      const opt = templateSelector.options[templateSelector.selectedIndex];
      const w = parseInt(opt.getAttribute('data-w') || "0", 10);
      const h = parseInt(opt.getAttribute('data-h') || "0", 10);
      const mode = opt.getAttribute('data-mode') || "";
      const guideSrc = templateSelector.value || "";
      const label = (opt.textContent || "").trim();
      return { w, h, mode, guideSrc, label };
    }

    function slugTemplateName(label){
      // remove any (...) and trim
      let t = (label || "").replace(/\(.*?\)/g, '').trim();
      t = t.replace(/\s+/g, ' ');
      // to slug with underscores
      t = t.replace(/[^a-zA-Z0-9]+/g, '_').replace(/^_+|_+$/g, '');
      if (!t) t = "TEMPLATE";
      return t.toUpperCase();
    }

    function updateExampleName(){
      const { label } = getTemplateSettings();
      const prefix = slugTemplateName(label);
      const base = (baseNameEl.value || "usa").trim() || "usa";
      const count = queue.length;
      if (count <= 1){
        nameExample.textContent = `Example: ${prefix}_${base}.jpg`;
      } else {
        nameExample.textContent = `Example: ${prefix}_${base}_1.jpg ‚Ä¶ ${prefix}_${base}_${count}.jpg`;
      }
    }

    function setStatus(html){
      statusEl.innerHTML = html || "";
    }

    function checkDownloadState(){
      const hasImages = queue.length > 0;
      const hasName = baseNameEl.value.trim().length > 0;
      const { w, h } = getTemplateSettings();
      const hasTemplate = w > 0 && h > 0;
      downloadAllBtn.disabled = !(hasImages && hasName && hasTemplate);
    }

    function showEditorOrDropzone(){
      const hasImages = queue.length > 0;
      if (hasImages){
        dropzone.style.display = "none";
        editorWindow.style.display = "flex";
        navRow.style.display = "flex";
      } else {
        dropzone.style.display = "flex";
        editorWindow.style.display = "none";
        navRow.style.display = "none";
      }
    }

    function updateNav(){
      const total = queue.length;
      navInfo.textContent = (total ? (currentIndex + 1) : 0) + " / " + total;
      prevBtn.disabled = (total <= 1 || currentIndex <= 0);
      nextBtn.disabled = (total <= 1 || currentIndex >= total - 1);
      queueCount.textContent = `${total} image(s)`;
      fileNameDisplay.innerHTML = total ? `‚úÖ ${total} image(s) loaded` : "üìÇ Click / Drop Images";
    }

    function renderQueue(){
      queueList.innerHTML = "";
      queue.forEach((item, idx) => {
        const row = document.createElement('div');
        row.className = 'queue-item' + (idx === currentIndex ? ' active' : '');
        row.addEventListener('click', () => {
          goToIndex(idx);
        });

        const left = document.createElement('div');
        left.className = 'qi-left';

        const badge = document.createElement('div');
        badge.className = 'qi-badge';
        badge.textContent = (idx + 1);

        const name = document.createElement('div');
        name.className = 'qi-name';
        name.title = item.name;
        name.textContent = item.name;

        left.appendChild(badge);
        left.appendChild(name);

        const size = document.createElement('div');
        size.className = 'qi-size';
        size.textContent = item.sizeText;

        row.appendChild(left);
        row.appendChild(size);

        queueList.appendChild(row);
      });
    }

    function removeOverlay(){
      document.querySelectorAll('.overlay-ghost').forEach(img => img.remove());
    }

    function updateOverlay(){
      removeOverlay();
      const { guideSrc, mode } = getTemplateSettings();
      const isWaveMode = mode === "wave";
      if (!guideSrc || isWaveMode) return;

      const cropFace = document.querySelector('.cropper-face');
      if (!cropFace) return;

      const ov = document.createElement('img');
      ov.src = guideSrc;
      ov.className = "overlay-ghost";
      cropFace.appendChild(ov);
    }

    function initCropperForCurrent(){
      if (cropper) {
        try { cropper.destroy(); } catch {}
        cropper = null;
      }

      const item = queue[currentIndex];
      if (!item) return;

      const { w, h, mode } = getTemplateSettings();
      const isWaveMode = mode === "wave";

      // if no template selected yet, allow move/zoom without crop box
      const hasTemplate = w > 0 && h > 0;
      const aspectRatio = hasTemplate ? (isWaveMode ? 1 : (w / h)) : NaN;

      imageEl.src = item.url;

      imageEl.onload = () => {
        cropper = new Cropper(imageEl, {
          aspectRatio: aspectRatio,
          viewMode: 1,
          dragMode: hasTemplate ? 'crop' : 'move',
          cropBoxMovable: true,
          cropBoxResizable: true,
          toggleDragModeOnDblclick: false,
          autoCropArea: 0.8,
          autoCrop: hasTemplate,
          background: false,
          guides: false,
          center: false,
          ready(){
            // Restore per-image crop state (if exists)
            const st = item.state || {};
            if (st.canvasData) { try { cropper.setCanvasData(st.canvasData); } catch {} }
            if (st.cropBoxData) { try { cropper.setCropBoxData(st.cropBoxData); } catch {} }
            if (st.data) { try { cropper.setData(st.data); } catch {} }

            // Apply current template ratio if selected
            if (hasTemplate){
              try { cropper.setAspectRatio(isWaveMode ? 1 : (w/h)); } catch {}
              try { cropper.crop(); } catch {}
              updateOverlay();
            } else {
              removeOverlay();
              try { cropper.clear(); } catch {}
            }

            checkDownloadState();
            updateExampleName();
          },
          cropend(){
            saveCurrentState();
          },
          zoom(){
            // save a bit later (avoid heavy)
            setTimeout(saveCurrentState, 40);
          }
        });
      };
    }

    function saveCurrentState(){
      const item = queue[currentIndex];
      if (!item || !cropper) return;
      try {
        item.state = {
          canvasData: cropper.getCanvasData(),
          cropBoxData: cropper.getCropBoxData(),
          data: cropper.getData(true)
        };
      } catch {}
    }

    function goToIndex(idx){
      if (idx < 0 || idx >= queue.length) return;
      // save old
      saveCurrentState();
      currentIndex = idx;
      renderQueue();
      updateNav();
      initCropperForCurrent();
    }

    function addFiles(files){
      if (!files || !files.length) return;

      const toAdd = [];
      for (const f of files){
        if (!f.type || !f.type.startsWith('image/')) continue;
        toAdd.push(f);
      }
      if (!toAdd.length) return;

      // append without clearing (Drag & Drop append)
      toAdd.forEach((file) => {
        const url = URL.createObjectURL(file);
        queue.push({
          file,
          url,
          name: file.name,
          sizeText: bytesToMB(file.size),
          state: null
        });
      });

      setStatus(`<span class="success">‚úÖ Added ${toAdd.length} image(s) to queue</span>`);

      showEditorOrDropzone();
      updateNav();
      renderQueue();
      updateExampleName();
      checkDownloadState();

      // if first time
      if (currentIndex === -1 && queue.length > 0){
        currentIndex = 0;
        renderQueue();
        updateNav();
        initCropperForCurrent();
      }
    }

    // ===== Upload via click =====
    inputEl.addEventListener('change', (e) => {
      const files = e.target.files;
      if (files && files.length){
        addFiles(files);
      }
      // allow re-select same files again
      inputEl.value = "";
    });

    // ===== Drag & Drop (append) =====
    function preventDefaults(e){
      e.preventDefault();
      e.stopPropagation();
    }

    ['dragenter','dragover','dragleave','drop'].forEach(ev => {
      dropzone.addEventListener(ev, preventDefaults, false);
      uploadBtn.addEventListener(ev, preventDefaults, false);
      editorWindow.addEventListener(ev, preventDefaults, false);
    });

    function setDragOver(on){
      if (on) dropzone.classList.add('dragover');
      else dropzone.classList.remove('dragover');
    }

    dropzone.addEventListener('dragenter', () => setDragOver(true));
    dropzone.addEventListener('dragleave', () => setDragOver(false));
    dropzone.addEventListener('dragover', () => setDragOver(true));
    dropzone.addEventListener('drop', (e) => {
      setDragOver(false);
      const dt = e.dataTransfer;
      if (dt && dt.files && dt.files.length){
        addFiles(dt.files);
      }
    });

    // Allow drop over editor too (after first image)
    editorWindow.addEventListener('drop', (e) => {
      const dt = e.dataTransfer;
      if (dt && dt.files && dt.files.length){
        addFiles(dt.files);
      }
    });

    // Make the dropzone clickable too
    dropzone.addEventListener('click', () => inputEl.click());

    // ===== Template change =====
    templateSelector.addEventListener('change', () => {
      const { w, h, mode } = getTemplateSettings();
      currentWidth = w || 0;
      currentHeight = h || 0;

      setStatus("");

      if (!queue.length){
        updateExampleName();
        checkDownloadState();
        return;
      }

      if (!cropper){
        initCropperForCurrent();
        updateExampleName();
        checkDownloadState();
        return;
      }

      // Apply ratio immediately to current cropper
      const isWaveMode = mode === "wave";
      if (w > 0 && h > 0){
        try { cropper.setAspectRatio(isWaveMode ? 1 : (w/h)); } catch {}
        try { cropper.crop(); } catch {}
        updateOverlay();
      } else {
        removeOverlay();
        try { cropper.clear(); } catch {}
      }

      // Save state after applying
      setTimeout(saveCurrentState, 60);

      updateExampleName();
      checkDownloadState();
    });

    // ===== Base name input =====
    baseNameEl.addEventListener('input', () => {
      updateExampleName();
      checkDownloadState();
    });

    // ===== Prev / Next =====
    prevBtn.addEventListener('click', () => {
      if (currentIndex > 0) goToIndex(currentIndex - 1);
    });
    nextBtn.addEventListener('click', () => {
      if (currentIndex < queue.length - 1) goToIndex(currentIndex + 1);
    });

    // ===== Grayscale only for BIG IMAGE (optional, keep your old rule) =====
    function applyGrayscale(canvas){
      const ctx = canvas.getContext('2d');
      const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
      const d = imgData.data;
      for (let i=0; i<d.length; i+=4){
        const r=d[i], g=d[i+1], b=d[i+2];
        const gray = (0.2126*r) + (0.7152*g) + (0.0722*b);
        d[i]=d[i+1]=d[i+2]=gray;
      }
      ctx.putImageData(imgData,0,0);
      return canvas;
    }

    // ===== Wave mode renderer (KEYPOINT LOGO) =====
    async function renderWaveOutput(cropCanvas, outW, outH){
      return new Promise((resolve, reject) => {
        const waveImg = new Image();
        waveImg.crossOrigin = "Anonymous";
        waveImg.src = 'static/images/wave.jpg?' + Date.now();

        waveImg.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = outW;
          canvas.height = outH;
          const ctx = canvas.getContext('2d');

          ctx.drawImage(waveImg, 0, 0, outW, outH);
          ctx.globalCompositeOperation = 'multiply';

          const scalePercentage = 0.65;
          const finalLogoWidth = outW * scalePercentage;
          const finalLogoHeight = finalLogoWidth;

          const posX = (outW - finalLogoWidth) / 2;
          const posY = 120;

          ctx.drawImage(
            cropCanvas,
            0, 0, cropCanvas.width, cropCanvas.height,
            posX, posY, finalLogoWidth, finalLogoHeight
          );

          ctx.globalCompositeOperation = 'source-over';
          resolve(canvas);
        };

        waveImg.onerror = () => reject(new Error("wave.jpg load failed"));
      });
    }

    function safeFileName(name){
      let safe = (name || "").replace(/[^a-zA-Z0-9\-_ ]/g, '').trim();
      if (!safe) safe = "image";
      return safe;
    }

    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function getPrefixAndBase(){
      const { label } = getTemplateSettings();
      const prefix = slugTemplateName(label);
      const base = safeFileName(baseNameEl.value.trim());
      return { prefix, base };
    }

    function setProcessingState(on){
      if (on){
        downloadAllBtn.disabled = true;
        downloadAllBtn.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i> Processing...`;
      } else {
        downloadAllBtn.innerHTML = `<i class="fa-solid fa-download"></i> Download All`;
        checkDownloadState();
      }
    }

    // ===== Download All =====
    downloadAllBtn.addEventListener('click', async () => {
      if (!queue.length || !cropper) return;

      const { w, h, mode, label } = getTemplateSettings();
      if (!(w > 0 && h > 0)){
        setStatus(`<span class="error">‚ö†Ô∏è Please select a template first!</span>`);
        return;
      }

      const base = baseNameEl.value.trim();
      if (!base){
        setStatus(`<span class="error">‚ö†Ô∏è Please enter a base name!</span>`);
        return;
      }

      saveCurrentState();

      const { prefix, base: safeBase } = getPrefixAndBase();
      const total = queue.length;
      const isWaveMode = mode === "wave";
      const templateLabel = (label || "").trim().toUpperCase();
      const isBigImageTemplate = templateLabel === "BIG IMAGE";

      setProcessingState(true);
      setStatus(`<span class="success">‚è≥ Preparing ${total} image(s)...</span>`);

      const originalIndex = currentIndex;

      try {
        for (let i = 0; i < total; i++){
          // switch to that image (restores its crop state)
          await new Promise((res) => {
            goToIndex(i);
            // wait for cropper ready
            setTimeout(res, 180);
          });

          // export canvas
          const cropCanvas = cropper.getCroppedCanvas({
            width: w,
            height: h,
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'medium'
          });

          let outCanvas = cropCanvas;

          if (isWaveMode){
            outCanvas = await renderWaveOutput(cropCanvas, w, h);
          } else {
            if (isBigImageTemplate){
              applyGrayscale(outCanvas);
            }
          }

          const fileIndexSuffix = (total > 1) ? `_${i+1}` : "";
          const filename = `${prefix}_${safeBase}${fileIndexSuffix}.jpg`;

          await new Promise((resolve) => {
            outCanvas.toBlob((blob) => {
              downloadBlob(blob, filename);
              resolve();
            }, 'image/jpeg', 0.95);
          });

          setStatus(`<span class="success">‚úÖ Downloaded ${i+1}/${total}</span>`);
          await new Promise(r => setTimeout(r, 120));
        }

        // restore original viewed image
        if (originalIndex >= 0 && originalIndex < total){
          goToIndex(originalIndex);
        }

        setStatus(`<span class="success">‚úÖ Done! Downloaded ${total} image(s)</span>`);
      } catch (err){
        console.error(err);
        setStatus(`<span class="error">‚ùå Error while exporting. Check wave.jpg/path or try again.</span>`);
      } finally {
        setProcessingState(false);
      }
    });

    // prevent duplicate drag selection inside crop area:
    // (Cropper can create new crop box when dragMode is 'crop'. We keep it but avoid "double" behavior by disabling toggle.)
    // Already handled by toggleDragModeOnDblclick: false, and we always save state.

    // Initial
    window.addEventListener('DOMContentLoaded', () => {
      showEditorOrDropzone();
      updateNav();
      renderQueue();
      updateExampleName();
      checkDownloadState();
      setStatus("");
    });
  </script>
</body>
</html>
