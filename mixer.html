<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Newsroom Tool - Unified</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;900&display=swap" rel="stylesheet">

  <style>
    body {
      margin: 0; padding: 0;
      background-color: #050505; color: white; font-family: 'Inter', sans-serif;
      overflow-x: hidden; display: flex; flex-direction: column; align-items: center; min-height: 100vh;
      background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.85)),
                url('./static/images/background-image.png') no-repeat center center fixed;
      background-size: cover;
    }

    .home-btn {
      position: absolute; top: 30px; left: 30px;
      text-decoration: none; color: #fff;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 20px; border-radius: 30px;
      display: flex; align-items: center; gap: 10px;
      font-weight: bold; font-family: 'Tajawal', sans-serif;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: 0.3s; z-index: 1000; backdrop-filter: blur(5px);
    }
    .home-btn:hover {
      background: rgba(255, 255, 255, 0.2); transform: scale(1.05);
      text-decoration: none; color: #fff; border-color: #2ecc71;
    }

    nav {
      display: flex; justify-content: space-between; align-items: center;
      width: 90%; max-width: 1200px; padding: 25px 0; z-index: 10; margin-bottom: 10px;
    }
    .logo-img { height: 70px; width: auto; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5)); }
    .version-badge { background: rgba(255,255,255,0.1); padding: 5px 12px; border-radius: 20px; font-size: 0.85rem; border: 1px solid rgba(255,255,255,0.2); color: #ccc; }

    .glass-container {
      width: 90%; max-width: 1300px;
      background: rgba(20, 20, 20, 0.6);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 24px; padding: 32px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.6);
      margin-bottom: 50px;
    }

    .layout-grid { display: grid; gap: 18px; align-items: start; }
    .layout-grid.no-queue { grid-template-columns: 1fr; }
    .layout-grid.has-queue { grid-template-columns: 1fr 360px; }

    @media (max-width: 980px) {
      .layout-grid.no-queue,
      .layout-grid.has-queue { grid-template-columns: 1fr; }
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 18px; margin-bottom: 14px;
    }

    label {
      display: block; margin-bottom: 10px; font-weight: 700; color: #e2e8f0;
      font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.5px;
    }

    select, .custom-file-upload, input[type="text"] {
      width: 100%; box-sizing: border-box; background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white; padding: 15px; border-radius: 12px;
      font-size: 1rem; outline: none; transition: all 0.3s;
    }
    select:hover, .custom-file-upload:hover, input[type="text"]:focus {
      border-color: #3b82f6; background: rgba(59, 130, 246, 0.1);
    }

    .custom-file-upload { cursor: pointer; display: flex; align-items: center; justify-content: space-between; }
    #fileNameDisplay { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 260px; display: inline-block; direction: ltr; }
    input[type="file"] { display: none; }

    option { background-color: #1a1a1a; color: white; padding: 10px; }
    option.has-guide { color: #ff6b6b; font-weight: bold; background-color: #2d1b1b; }
    optgroup { font-weight: bold; color: #94a3b8; background-color: #0f0f0f; }

    .nav-row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    .btn-secondary {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #fff;
      padding: 14px 16px;
      border-radius: 12px;
      font-weight: 800;
      cursor: pointer;
      transition: 0.2s;
      width: 100%;
    }
    .btn-secondary:hover { background: rgba(255,255,255,0.14); transform: translateY(-1px); }
    .btn-secondary:disabled { opacity: 0.45; cursor: not-allowed; transform: none; }

    .img-window {
      height: 650px;
      border-radius: 16px;
      overflow: hidden; position: relative;
      border: 1px dashed rgba(255, 255, 255, 0.22);
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.22);
    }
    img { max-width: 100%; display: block; }

    .dropzone {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 28px;
      text-align: center;
      cursor: pointer;
      user-select: none;
      z-index: 20;
    }

    .drop-card {
      width: min(640px, 92%);
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 22px 20px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: 0.18s;
    }

    .drop-icon {
      width: 54px; height: 54px;
      border-radius: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(59,130,246,0.14);
      border: 1px solid rgba(59,130,246,0.25);
      margin-bottom: 12px;
      font-size: 22px;
      color: #93c5fd;
    }

    .drop-title {
      font-weight: 900;
      font-size: 1.05rem;
      margin-bottom: 8px;
      color: #e5e7eb;
      font-family: 'Tajawal', sans-serif;
    }

    .drop-sub {
      font-size: 0.92rem;
      line-height: 1.45;
      color: #a3a3a3;
      margin-bottom: 10px;
    }

    .drop-hint {
      font-size: 0.85rem;
      color: #9ca3af;
      direction: ltr;
    }

    .dropzone.dragover .drop-card {
      transform: scale(1.02);
      border-color: rgba(59,130,246,0.7);
      background: rgba(59,130,246,0.10);
      box-shadow: 0 18px 45px rgba(0,0,0,0.45);
    }

    .filename-section { margin-top: 14px; }

    .btn-save {
      margin-top: 12px;
      background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
      color: #0f172a; border: none; padding: 16px 26px; border-radius: 12px;
      font-size: 1.05rem; font-weight: 800; cursor: pointer; width: 100%;
      transition: 0.3s;
    }
    .btn-save:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(255, 255, 255, 0.2); background: white; }
    .btn-save:disabled { background: #444; color: #888; cursor: not-allowed; transform: none; box-shadow: none; }

    .hint {
      margin-top: 8px;
      font-size: 0.9rem;
      color: #a3a3a3;
      direction: ltr;
    }

    .queue-wrap {
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      position: sticky;
      top: 18px;
      height: calc(650px + 220px);
      display: flex;
      flex-direction: column;
    }
    @media (max-width: 980px) {
      .queue-wrap { position: relative; top: auto; height: auto; }
    }

    .queue-title {
      display: flex; align-items: center; justify-content: space-between;
      font-family: 'Tajawal', sans-serif;
      font-weight: 900;
      margin-bottom: 12px;
      color: #e5e7eb;
    }
    .queue-title small {
      font-weight: 700;
      color: #a3a3a3;
      font-family: 'Inter', sans-serif;
    }
    .queue-list { overflow: auto; padding-right: 4px; flex: 1; max-height: 100%; }
    .queue-item {
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      margin-bottom: 10px;
      cursor: pointer;
      transition: 0.15s;
    }
    .queue-item:hover { background: rgba(255,255,255,0.07); }
    .queue-item.active {
      border-color: rgba(59,130,246,0.8);
      background: rgba(59,130,246,0.14);
    }
    .queue-left { display: flex; align-items: center; gap: 10px; min-width: 0; }
    .queue-badge {
      min-width: 28px; height: 28px;
      display: inline-flex; align-items: center; justify-content: center;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      font-weight: 900;
      color: #e5e7eb;
      flex: 0 0 auto;
    }
    .queue-name {
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      max-width: 220px;
      direction: ltr;
      font-weight: 700;
      color: #e5e7eb;
    }
    .queue-size { font-size: 0.85rem; color: #a3a3a3; flex: 0 0 auto; }

    .overlay-ghost {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 9999;
      pointer-events: none !important;
      opacity: 1 !important;
      object-fit: fill;
    }

    .cropper-face { background-color: transparent !important; opacity: 1 !important; }
    .cropper-point { z-index: 100 !important; background-color: #3b82f6; width: 10px; height: 10px; }
    .cropper-view-box { outline: 2px solid #3b82f6; }

    #status { margin-top: 14px; text-align: center; }
    .success { color: #4ade80; background: rgba(74, 222, 128, 0.1); padding: 10px 20px; border-radius: 8px; border: 1px solid #4ade80; display: inline-block;}
    .error { color: #f87171; background: rgba(248, 113, 113, 0.1); padding: 10px 20px; border-radius: 8px; border: 1px solid #f87171; display: inline-block;}
  </style>
</head>

<body>
  <a href="./index.html" class="home-btn"><i class="fas fa-home"></i> ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</a>

  <nav>
    <img src="./static/images/logo.png" alt="Channel Logo" class="logo-img">
    <div class="version-badge">ÿßŸÑÿ™ŸÑŸÅÿ≤ŸäŸàŸÜ ÿßŸÑÿπÿ±ÿ®Ÿä</div>
  </nav>

  <div class="glass-container">
    <div class="layout-grid no-queue" id="layoutGrid">
      <!-- LEFT -->
      <div>
        <div class="controls-grid">
          <div>
            <label>1. Source Image</label>
            <label class="custom-file-upload">
              <input type="file" id="uploadInput" accept="image/*" multiple>
              <span id="fileNameDisplay">üìÇ CLICK TO UPLOAD IMAGE...</span>
            </label>
          </div>

          <div>
            <label>2. Select Template</label>
            <select id="templateSelector">
              <option value="" data-w="" data-h="">-- Select Format --</option>

              <optgroup label="GUIDE (Red Zones)">
                <option class="has-guide" value="./static/images/KEYPOINT.png" data-w="654" data-h="1024" data-mode="wave">KEYPOINT LOGO (Wave)</option>
                <option class="has-guide" value="./static/images/phono_guide.png" data-w="853" data-h="1024">PHONO (853x1024)</option>
                <option class="has-guide" value="./static/images/KEYPOINT.png" data-w="654" data-h="1024">KEYPOINT (654x1024)</option>
                <option class="has-guide" value="./static/images/AK HEADLINE.png" data-w="1024" data-h="616">AK HEADLINE (1024x616)</option>
                <option class="has-guide" value="./static/images/LK.png" data-w="1024" data-h="1024">LK (1024x1024)</option>
              </optgroup>

              <optgroup label="NO GUIDE (Clean)">
                <option value="" data-w="1024" data-h="746">V.WALL B </option>
                <option value="" data-w="1920" data-h="1080">TOPICAL STING </option>
                <option value="" data-w="743" data-h="1024">V.WALL G </option>
                <option value="" data-w="1152" data-h="1944">V.WALL A </option>
                <option value="" data-w="660" data-h="1024">BIG IMAGE </option>
                <option value="" data-w="1024" data-h="770">SMALL IMAGE </option>
              </optgroup>
            </select>
          </div>
        </div>

        <div class="nav-row">
          <button id="prevBtn" class="btn-secondary" disabled>‚¨ÖÔ∏è Previous</button>
          <button id="infoBtn" class="btn-secondary" disabled style="cursor: default;">0 / 0</button>
          <button id="nextBtn" class="btn-secondary" disabled>Next ‚û°Ô∏è</button>
        </div>

        <div class="img-window" id="imgWindow">
          <img id="image" src="" alt="">

          <div class="dropzone" id="dropzone">
            <div class="drop-card">
              <div class="drop-icon"><i class="fa-solid fa-cloud-arrow-up"></i></div>
              <div class="drop-title">ÿßÿ±ŸÅÿπ ÿßŸÑÿµŸàÿ± ÿ≠ÿ™Ÿâ ŸÜÿ®ÿØÿ£</div>
              <div class="drop-sub">
                ÿßÿ≥ÿ≠ÿ® ÿßŸÑÿµŸàÿ± Ÿàÿ£ŸÅŸÑÿ™Ÿáÿß ŸáŸÜÿßÿå ÿ£Ÿà ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÅÿ™ÿ≠ ŸÜÿßŸÅÿ∞ÿ© ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖŸÑŸÅÿßÿ™.<br>
                ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ•ÿ∂ÿßŸÅÿ© ŸÑÿßÿ≠ŸÇÿßŸã ÿ£Ÿäÿ∂ÿßŸã ÿ®ÿØŸàŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑÿµŸàÿ± ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©.
              </div>
              <div class="drop-hint">Tip: Multiple Images (PNG/JPG/WebP)</div>
            </div>
          </div>
        </div>

        <div class="filename-section">
          <label for="customFileName">3. Base Name (Write once):</label>
          <input type="text" id="customFileName" placeholder="Type base name (e.g. usa)...">
          <div class="hint" id="finalPreview">Example: TEMPLATE_usa_1.jpg</div>
        </div>

        <button id="cropBtn" class="btn-save" disabled>Download All ‚¨áÔ∏è</button>
        <div id="status"></div>
      </div>

      <!-- RIGHT: Queue -->
      <div class="queue-wrap" id="queueWrap" style="display:none;">
        <div class="queue-title">
          <div>Queue</div>
          <small id="queueMeta">0 image(s)</small>
        </div>
        <div class="queue-list" id="queueList"></div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <script>
    const image = document.getElementById('image');
    const input = document.getElementById('uploadInput');
    const templateSelector = document.getElementById('templateSelector');
    const status = document.getElementById('status');
    const fileNameDisplay = document.getElementById('fileNameDisplay');
    const customFileNameInput = document.getElementById('customFileName');
    const cropBtn = document.getElementById('cropBtn');

    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const infoBtn = document.getElementById('infoBtn');

    const queueWrap = document.getElementById('queueWrap');
    const queueList = document.getElementById('queueList');
    const queueMeta = document.getElementById('queueMeta');
    const finalPreview = document.getElementById('finalPreview');

    const layoutGrid = document.getElementById('layoutGrid');
    const dropzone = document.getElementById('dropzone');
    const imgWindow = document.getElementById('imgWindow');

    let cropper;
    let currentWidth = 0;
    let currentHeight = 0;

    let imageQueue = [];
    let currentIndex = -1;
    let currentObjectURL = null;

    let cropperReadyResolver = null;
    let waveCachePromise = null;

    const cropStateByIndex = new Map();

    function setStatus(html) { status.innerHTML = html || ""; }

    function setLayout(hasQueue) {
      if (hasQueue) {
        layoutGrid.classList.remove("no-queue");
        layoutGrid.classList.add("has-queue");
        queueWrap.style.display = "flex";
        dropzone.style.display = "none";
      } else {
        layoutGrid.classList.add("no-queue");
        layoutGrid.classList.remove("has-queue");
        queueWrap.style.display = "none";
        dropzone.style.display = "flex";
      }
    }

    function formatBytes(bytes) {
      if (!Number.isFinite(bytes)) return "";
      const units = ["B","KB","MB","GB"];
      let i = 0, n = bytes;
      while (n >= 1024 && i < units.length - 1) { n /= 1024; i++; }
      return `${n.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
    }

    function getTemplatePrefix() {
      const opt = templateSelector.options[templateSelector.selectedIndex];
      if (!opt) return "";
      const raw = (opt.textContent || "").trim();
      const noParens = raw.replace(/\(.*?\)/g, "").trim();
      const underscored = noParens.replace(/\s+/g, "_").toUpperCase();
      return underscored.replace(/[^A-Z0-9_]/g, "");
    }

    function sanitizeBaseName(name) {
      let s = (name || "").trim();
      s = s.replace(/[^a-zA-Z0-9\-_ ]/g, "");
      s = s.replace(/\s+/g, "_");
      return s;
    }

    function buildFinalFileName(i1) {
      const prefix = getTemplatePrefix();
      const base = sanitizeBaseName(customFileNameInput.value);
      if (!prefix || !base) return "";
      return `${prefix}_${base}_${i1}.jpg`;
    }

    function updateFinalPreview() {
      const name = buildFinalFileName(Math.max(1, currentIndex + 1));
      finalPreview.textContent = name ? `Example: ${name}` : "Example: TEMPLATE_usa_1.jpg";
    }

    function updateHeaderDisplay() {
      if (imageQueue.length === 0) {
        fileNameDisplay.innerHTML = "üìÇ CLICK TO UPLOAD IMAGE...";
        infoBtn.innerText = "0 / 0";
        return;
      }
      fileNameDisplay.innerHTML = `‚úÖ ${imageQueue.length} image(s) loaded`;
      infoBtn.innerText = `${currentIndex + 1} / ${imageQueue.length}`;
    }

    function updateNavButtons() {
      const hasQueue = imageQueue.length > 0;
      prevBtn.disabled = !(hasQueue && currentIndex > 0);
      nextBtn.disabled = !(hasQueue && currentIndex < imageQueue.length - 1);
      infoBtn.disabled = !hasQueue;
      infoBtn.style.opacity = hasQueue ? "1" : "0.5";
    }

    function setUiBusy(isBusy) {
      input.disabled = isBusy;
      templateSelector.disabled = isBusy;
      customFileNameInput.disabled = isBusy;
      prevBtn.disabled = isBusy || !(imageQueue.length > 0 && currentIndex > 0);
      nextBtn.disabled = isBusy || !(imageQueue.length > 0 && currentIndex < imageQueue.length - 1);
    }

    function renderQueue() {
      if (imageQueue.length === 0) {
        queueList.innerHTML = "";
        queueMeta.innerText = "0 image(s)";
        return;
      }

      queueMeta.innerText = `${imageQueue.length} image(s)`;
      queueList.innerHTML = "";

      imageQueue.forEach((file, idx) => {
        const item = document.createElement("div");
        item.className = "queue-item" + (idx === currentIndex ? " active" : "");
        item.title = "Click to open";

        const left = document.createElement("div");
        left.className = "queue-left";

        const badge = document.createElement("div");
        badge.className = "queue-badge";
        badge.innerText = String(idx + 1);

        const name = document.createElement("div");
        name.className = "queue-name";
        name.innerText = file.name;

        left.appendChild(badge);
        left.appendChild(name);

        const size = document.createElement("div");
        size.className = "queue-size";
        size.innerText = formatBytes(file.size);

        item.appendChild(left);
        item.appendChild(size);

        item.addEventListener("click", () => {
          if (idx !== currentIndex) loadImageAt(idx);
        });

        queueList.appendChild(item);
      });
    }

    function cleanupObjectURL() {
      if (currentObjectURL) {
        URL.revokeObjectURL(currentObjectURL);
        currentObjectURL = null;
      }
    }

    function waitForCropperReady() {
      return new Promise(resolve => { cropperReadyResolver = resolve; });
    }

    function saveCurrentCropState() {
      if (!cropper) return;
      if (currentIndex < 0) return;
      if (!(currentWidth > 0 && currentHeight > 0)) return;

      try {
        cropStateByIndex.set(currentIndex, {
          data: cropper.getData(true),
          cropBoxData: cropper.getCropBoxData(),
          canvasData: cropper.getCanvasData()
        });
      } catch (e) {}
    }

    function restoreCropStateForIndex() {
      if (!cropper) return false;
      const st = cropStateByIndex.get(currentIndex);
      if (!st) return false;

      try {
        cropper.setCanvasData(st.canvasData);
        cropper.setCropBoxData(st.cropBoxData);
        cropper.setData(st.data);
        return true;
      } catch (e) {
        return false;
      }
    }

    function setMaxCropBox(aspectRatio) {
      if (!cropper) return;

      const canvas = cropper.getCanvasData();
      if (!canvas || !canvas.width || !canvas.height) return;

      const padding = 2;
      const maxW = Math.max(0, canvas.width - padding * 2);
      const maxH = Math.max(0, canvas.height - padding * 2);

      let boxW = maxW;
      let boxH = boxW / aspectRatio;

      if (boxH > maxH) {
        boxH = maxH;
        boxW = boxH * aspectRatio;
      }

      const left = canvas.left + (canvas.width - boxW) / 2;
      const top  = canvas.top  + (canvas.height - boxH) / 2;

      cropper.setCropBoxData({ left, top, width: boxW, height: boxH });
    }

    function loadImageAt(index) {
      if (index < 0 || index >= imageQueue.length) return;

      saveCurrentCropState();

      currentIndex = index;
      cleanupObjectURL();

      const file = imageQueue[currentIndex];
      currentObjectURL = URL.createObjectURL(file);
      image.src = currentObjectURL;

      setStatus("");

      if (currentWidth > 0 && currentHeight > 0) initCropper();
      else initInitialView();

      updateHeaderDisplay();
      updateNavButtons();
      renderQueue();
      checkDownloadState();
      updateFinalPreview();
    }

    function checkDownloadState() {
      const base = sanitizeBaseName(customFileNameInput.value);
      const isNameEntered = base.length > 0;
      const isImageLoaded = !!(image.src && image.src !== "");
      const isTemplateSelected = currentWidth > 0 && currentHeight > 0 && getTemplatePrefix().length > 0;
      const hasQueue = imageQueue.length > 0;

      cropBtn.disabled = !(isImageLoaded && isNameEntered && isTemplateSelected && hasQueue);
      cropBtn.style.opacity = cropBtn.disabled ? "0.5" : "1";
      updateFinalPreview();
      setLayout(hasQueue);
    }

    customFileNameInput.addEventListener("input", checkDownloadState);

    prevBtn.addEventListener("click", () => { if (currentIndex > 0) loadImageAt(currentIndex - 1); });
    nextBtn.addEventListener("click", () => { if (currentIndex < imageQueue.length - 1) loadImageAt(currentIndex + 1); });

    function fileKey(f) {
      return `${f.name}__${f.size}__${f.lastModified || 0}`;
    }

    function processSelectedFiles(fileList) {
      const files = Array.from(fileList || []);
      if (!files.length) return;

      const onlyImages = files.filter(f => f.type && f.type.startsWith("image/"));
      if (!onlyImages.length) {
        setStatus('<span class="error">‚ùå No valid images selected.</span>');
        return;
      }

      const existingKeys = new Set(imageQueue.map(fileKey));

      const newOnes = [];
      for (const f of onlyImages) {
        const k = fileKey(f);
        if (!existingKeys.has(k)) {
          existingKeys.add(k);
          newOnes.push(f);
        }
      }

      if (!newOnes.length) {
        setStatus('<span class="error">‚ö†Ô∏è These images are already in the queue.</span>');
        return;
      }

      const wasEmpty = (imageQueue.length === 0);

      imageQueue = imageQueue.concat(newOnes);

      if (wasEmpty) {
        cropStateByIndex.clear();
        currentIndex = 0;
        updateHeaderDisplay();
        updateNavButtons();
        renderQueue();
        updateFinalPreview();
        checkDownloadState();
        loadImageAt(0);
      } else {
        updateHeaderDisplay();
        updateNavButtons();
        renderQueue();
        updateFinalPreview();
        checkDownloadState();
        setStatus(`<span class="success">‚úÖ Added ${newOnes.length} image(s) to queue</span>`);
      }
    }

    input.addEventListener('change', function (e) {
      processSelectedFiles(e.target.files);
      input.value = "";
    });

    function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

    ["dragenter","dragover","dragleave","drop"].forEach(evt => {
      dropzone.addEventListener(evt, preventDefaults, false);
      imgWindow.addEventListener(evt, preventDefaults, false);
    });

    ["dragenter","dragover"].forEach(evt => {
      imgWindow.addEventListener(evt, () => dropzone.classList.add("dragover"), false);
      dropzone.addEventListener(evt, () => dropzone.classList.add("dragover"), false);
    });

    ["dragleave","drop"].forEach(evt => {
      imgWindow.addEventListener(evt, () => dropzone.classList.remove("dragover"), false);
      dropzone.addEventListener(evt, () => dropzone.classList.remove("dragover"), false);
    });

    function handleDropFiles(e) {
      const dt = e.dataTransfer;
      if (!dt) return;
      processSelectedFiles(dt.files);
    }

    imgWindow.addEventListener("drop", handleDropFiles);
    dropzone.addEventListener("drop", handleDropFiles);

    dropzone.addEventListener("click", () => input.click());

    function initInitialView() {
      if (cropper) cropper.destroy();
      cropper = new Cropper(image, {
        viewMode: 1,
        dragMode: 'move',
        autoCrop: false,
        background: false,
        ready: function() {
          removeOverlay();
          checkDownloadState();
          if (cropperReadyResolver) { const r = cropperReadyResolver; cropperReadyResolver = null; r(); }
        }
      });
    }

    templateSelector.addEventListener('change', function() {
      saveCurrentCropState();

      const selectedOption = templateSelector.options[templateSelector.selectedIndex];
      const w = selectedOption.getAttribute('data-w');
      const h = selectedOption.getAttribute('data-h');

      setStatus("");

      if (w && h) {
        currentWidth = parseInt(w, 10);
        currentHeight = parseInt(h, 10);
        if (image.src && image.src !== "") initCropper();
      } else {
        currentWidth = 0;
        currentHeight = 0;
        if (image.src && image.src !== "") initInitialView();
        else { if (cropper) cropper.destroy(); cropper = null; }
        removeOverlay();
      }

      checkDownloadState();
      updateFinalPreview();
    });

    function initCropper() {
      if (cropper) cropper.destroy();

      const selectedOption = templateSelector.options[templateSelector.selectedIndex];
      const isWaveMode = selectedOption.getAttribute('data-mode') === 'wave';
      const aspectRatio = isWaveMode ? 1 : currentWidth / currentHeight;

      cropper = new Cropper(image, {
        aspectRatio: aspectRatio,
        viewMode: 1,
        dragMode: 'crop',
        cropBoxMovable: true,
        cropBoxResizable: true,
        toggleDragModeOnDblclick: false,
        autoCropArea: 0.95,
        background: false,
        ready: function () {
          updateOverlay();

          const restored = restoreCropStateForIndex();
          if (!restored) setMaxCropBox(aspectRatio);

          checkDownloadState();

          if (cropperReadyResolver) { const r = cropperReadyResolver; cropperReadyResolver = null; r(); }
        }
      });
    }

    function updateOverlay() {
      removeOverlay();

      const selectedValue = templateSelector.value;
      const selectedOption = templateSelector.options[templateSelector.selectedIndex];
      const isWaveMode = selectedOption.getAttribute('data-mode') === 'wave';
      if (!selectedValue || selectedValue === "" || isWaveMode) return;

      const viewBox = document.querySelector('.cropper-view-box');
      if (!viewBox) return;

      const img = document.createElement('img');
      img.src = selectedValue;
      img.className = 'overlay-ghost';

      viewBox.style.position = "relative";
      viewBox.appendChild(img);
    }

    function removeOverlay() {
      document.querySelectorAll('.overlay-ghost').forEach(el => el.remove());
    }

    function applyGrayscale(canvas) {
      const ctx = canvas.getContext('2d');
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const d = imgData.data;
      for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i + 1], b = d[i + 2];
        const gray = (0.2126 * r) + (0.7152 * g) + (0.0722 * b);
        d[i] = d[i + 1] = d[i + 2] = gray;
      }
      ctx.putImageData(imgData, 0, 0);
      return canvas;
    }

    function downloadBlob(blob, finalFileNameWithExt) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = finalFileNameWithExt;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function loadWaveImageOnce() {
      if (waveCachePromise) return waveCachePromise;
      waveCachePromise = new Promise((resolve, reject) => {
        const waveImg = new Image();
        waveImg.crossOrigin = "Anonymous";
        waveImg.src = './static/images/wave.jpg?' + new Date().getTime();
        waveImg.onload = () => resolve(waveImg);
        waveImg.onerror = () => reject(new Error("wave.jpg failed"));
      });
      return waveCachePromise;
    }

    function canvasToBlob(canvas, quality = 0.95) {
      return new Promise(resolve => canvas.toBlob(blob => resolve(blob), 'image/jpeg', quality));
    }

    async function exportCurrentToBlob(isWaveMode, isBigImageTemplate) {
      if (!cropper) throw new Error("Cropper not ready");

      if (isWaveMode) {
        const waveImg = await loadWaveImageOnce();

        const canvas = document.createElement('canvas');
        canvas.width = currentWidth;
        canvas.height = currentHeight;
        const ctx = canvas.getContext('2d');

        ctx.drawImage(waveImg, 0, 0, currentWidth, currentHeight);
        ctx.globalCompositeOperation = 'multiply';

        const rawCroppedCanvas = cropper.getCroppedCanvas();
        const scalePercentage = 0.65;
        const finalLogoWidth = currentWidth * scalePercentage;
        const finalLogoHeight = finalLogoWidth;

        const posX = (currentWidth - finalLogoWidth) / 2;
        const posY = 120;

        ctx.drawImage(
          rawCroppedCanvas,
          0, 0, rawCroppedCanvas.width, rawCroppedCanvas.height,
          posX, posY, finalLogoWidth, finalLogoHeight
        );

        ctx.globalCompositeOperation = 'source-over';
        return await canvasToBlob(canvas, 0.95);
      } else {
        const canvas = cropper.getCroppedCanvas({ width: currentWidth, height: currentHeight });
        if (isBigImageTemplate) applyGrayscale(canvas);
        return await canvasToBlob(canvas, 0.95);
      }
    }

    cropBtn.addEventListener('click', async function () {
      try {
        if (!imageQueue.length) return;

        const base = sanitizeBaseName(customFileNameInput.value);
        if (!base) {
          setStatus('<span class="error">‚ö†Ô∏è Please enter a base name!</span>');
          return;
        }

        if (currentWidth === 0 || currentHeight === 0 || !getTemplatePrefix()) {
          setStatus('<span class="error">‚ö†Ô∏è Please select a template first!</span>');
          return;
        }

        const selectedOption = templateSelector.options[templateSelector.selectedIndex];
        const isWaveMode = selectedOption.getAttribute('data-mode') === 'wave';
        const templateLabel = (selectedOption.textContent || "").trim().toUpperCase();
        const isBigImageTemplate = templateLabel === "BIG IMAGE";

        const originalText = cropBtn.innerText;
        cropBtn.innerText = "Processing All...";
        cropBtn.disabled = true;
        setUiBusy(true);

        setStatus(`‚è≥ Exporting ${imageQueue.length} image(s)...`);

        for (let i = 0; i < imageQueue.length; i++) {
          loadImageAt(i);
          await waitForCropperReady();

          const finalFileName = buildFinalFileName(i + 1);
          setStatus(`‚è≥ (${i + 1}/${imageQueue.length}) Generating: <b>${finalFileName}</b> ...`);

          const blob = await exportCurrentToBlob(isWaveMode, isBigImageTemplate);
          downloadBlob(blob, finalFileName);

          await new Promise(r => setTimeout(r, 180));
        }

        cropBtn.innerText = originalText;
        cropBtn.disabled = false;
        setUiBusy(false);

        setStatus(`<span class="success">‚úÖ Downloaded all: ${imageQueue.length} file(s)</span>`);
        checkDownloadState();

      } catch (err) {
        cropBtn.innerText = "Download All ‚¨áÔ∏è";
        cropBtn.disabled = false;
        setUiBusy(false);
        setStatus(`<span class="error">‚ùå ${String(err.message || err)}</span>`);
        checkDownloadState();
      }
    });

    window.addEventListener('DOMContentLoaded', () => {
      setLayout(false);
      updateHeaderDisplay();
      updateNavButtons();
      renderQueue();
      checkDownloadState();
      updateFinalPreview();
    });
  </script>
</body>
</html>
